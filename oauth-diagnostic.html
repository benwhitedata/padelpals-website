<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OAuth Diagnostic Tool - Padel Pals</title>
    <link rel="icon" href="images/Icon.png" type="image/png">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="config-loader.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #4A90E2 0%, #1a2238 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        .header h1 {
            font-size: 2rem;
            margin-bottom: 10px;
        }
        .content {
            padding: 30px;
        }
        .section {
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 12px;
            border-left: 4px solid #4A90E2;
        }
        .section.error {
            border-left-color: #dc3545;
            background: #fff5f5;
        }
        .section.success {
            border-left-color: #28a745;
            background: #f0fff4;
        }
        .section.warning {
            border-left-color: #ffc107;
            background: #fffef0;
        }
        .section h2 {
            color: #1a2238;
            margin-bottom: 15px;
            font-size: 1.3rem;
        }
        .check-item {
            padding: 10px;
            margin: 8px 0;
            background: white;
            border-radius: 6px;
            display: flex;
            align-items: flex-start;
            gap: 10px;
        }
        .check-item.success::before {
            content: "‚úì";
            color: #28a745;
            font-weight: bold;
            font-size: 1.2rem;
            flex-shrink: 0;
        }
        .check-item.error::before {
            content: "‚úó";
            color: #dc3545;
            font-weight: bold;
            font-size: 1.2rem;
            flex-shrink: 0;
        }
        .check-item.warning::before {
            content: "‚ö†";
            color: #ffc107;
            font-weight: bold;
            font-size: 1.2rem;
            flex-shrink: 0;
        }
        .check-item.info::before {
            content: "‚Ñπ";
            color: #4A90E2;
            font-weight: bold;
            font-size: 1.2rem;
            flex-shrink: 0;
        }
        .check-item-content {
            flex: 1;
            word-wrap: break-word;
        }
        code {
            background: #e9ecef;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            word-break: break-all;
            display: inline-block;
        }
        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 15px;
        }
        button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            background: #4A90E2;
            color: white;
        }
        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(74, 144, 226, 0.4);
        }
        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        button.secondary {
            background: #6c757d;
        }
        button.danger {
            background: #dc3545;
        }
        button.success {
            background: #28a745;
        }
        .details {
            margin-top: 10px;
            padding: 10px;
            background: white;
            border-radius: 6px;
            font-size: 0.9rem;
            max-height: 300px;
            overflow-y: auto;
        }
        .instructions {
            background: #e7f3ff;
            border-left: 4px solid #4A90E2;
            padding: 15px;
            margin: 15px 0;
            border-radius: 6px;
        }
        .instructions h3 {
            color: #1a2238;
            margin-bottom: 10px;
        }
        .instructions ol, .instructions ul {
            margin-left: 20px;
        }
        .instructions li {
            margin: 8px 0;
        }
        .collapsible {
            cursor: pointer;
            user-select: none;
        }
        .collapsible:hover {
            background: rgba(0,0,0,0.05);
        }
        .collapsible-content {
            display: none;
            padding-left: 30px;
            margin-top: 5px;
        }
        .collapsible-content.expanded {
            display: block;
        }
        .progress-bar {
            width: 100%;
            height: 6px;
            background: #e9ecef;
            border-radius: 3px;
            overflow: hidden;
            margin: 15px 0;
        }
        .progress-fill {
            height: 100%;
            background: #4A90E2;
            transition: width 0.3s ease;
        }
        .summary {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 2px solid #4A90E2;
        }
        .summary h3 {
            color: #1a2238;
            margin-bottom: 10px;
        }
        .summary-item {
            padding: 5px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîç Enhanced OAuth Diagnostic Tool</h1>
            <p>Comprehensive authentication diagnostics</p>
        </div>
        
        <div class="content">
            <div class="section">
                <h2>Quick Actions</h2>
                <div class="button-group">
                    <button onclick="runFullDiagnostic()" id="fullDiagnosticBtn">üî¨ Run Full Diagnostic</button>
                    <button onclick="testOAuthFlow()" class="secondary" id="testFlowBtn">üîÑ Test OAuth Flow</button>
                    <button onclick="testStorage()" class="secondary">üíæ Analyse Storage</button>
                    <button onclick="testURLHash()" class="secondary">üîó Check URL Hash</button>
                    <button onclick="exportDiagnosticReport()" class="success" id="exportBtn">üìã Export Report</button>
                    <button onclick="startErrorMonitoring()" class="secondary" id="monitorBtn">üëÅÔ∏è Start Monitoring</button>
                    <button onclick="clearAllData()" class="danger">üóëÔ∏è Clear All Data</button>
                </div>
                <div class="progress-bar" id="progressBar" style="display: none;">
                    <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                </div>
            </div>

            <div id="summary"></div>
            <div id="results"></div>
        </div>
    </div>

    <script>
        const SUPABASE_CALLBACK_URL = 'https://peaphqbxdmknxzsfdxuh.supabase.co/auth/v1/callback';
        const WEBSITE_CALLBACK_URL = 'https://www.padelpals.app/auth-callback.html';
        const SUPABASE_URL = 'https://peaphqbxdmknxzsfdxuh.supabase.co';

        let testResults = {
            total: 0,
            passed: 0,
            failed: 0,
            warnings: 0
        };

        // Enhanced error collection system
        let errorMonitor = {
            active: false,
            consoleErrors: [],
            networkErrors: [],
            oauthFlowSteps: [],
            monitoringStartTime: null,
            originalConsoleError: null,
            originalConsoleWarn: null
        };

        // Capture console errors
        function captureConsoleErrors() {
            if (errorMonitor.active) return;
            
            errorMonitor.active = true;
            errorMonitor.monitoringStartTime = Date.now();
            
            // Store original console methods
            errorMonitor.originalConsoleError = console.error;
            errorMonitor.originalConsoleWarn = console.warn;
            
            // Override console.error
            console.error = function(...args) {
                const errorInfo = {
                    timestamp: Date.now(),
                    type: 'console_error',
                    message: args.map(arg => {
                        if (arg instanceof Error) {
                            return {
                                message: arg.message,
                                stack: arg.stack,
                                name: arg.name
                            };
                        }
                        return String(arg);
                    }).join(' '),
                    args: args,
                    url: window.location.href
                };
                
                errorMonitor.consoleErrors.push(errorInfo);
                
                // Keep only last 50 errors
                if (errorMonitor.consoleErrors.length > 50) {
                    errorMonitor.consoleErrors.shift();
                }
                
                // Store in localStorage for persistence
                try {
                    const storedErrors = JSON.parse(localStorage.getItem('oauth_console_errors') || '[]');
                    storedErrors.push(errorInfo);
                    if (storedErrors.length > 100) {
                        storedErrors.shift();
                    }
                    localStorage.setItem('oauth_console_errors', JSON.stringify(storedErrors));
                } catch (e) {
                    // Ignore storage errors
                }
                
                // Call original console.error
                errorMonitor.originalConsoleError.apply(console, args);
            };
            
            // Override console.warn
            console.warn = function(...args) {
                const warnInfo = {
                    timestamp: Date.now(),
                    type: 'console_warning',
                    message: args.map(arg => String(arg)).join(' '),
                    args: args,
                    url: window.location.href
                };
                
                // Store warnings related to auth
                if (warnInfo.message.toLowerCase().includes('auth') || 
                    warnInfo.message.toLowerCase().includes('oauth') ||
                    warnInfo.message.toLowerCase().includes('supabase')) {
                    errorMonitor.consoleErrors.push(warnInfo);
                }
                
                errorMonitor.originalConsoleWarn.apply(console, args);
            };
            
            // Capture unhandled errors
            window.addEventListener('error', (event) => {
                const errorInfo = {
                    timestamp: Date.now(),
                    type: 'unhandled_error',
                    message: event.message,
                    filename: event.filename,
                    lineno: event.lineno,
                    colno: event.colno,
                    stack: event.error?.stack,
                    url: window.location.href
                };
                
                errorMonitor.consoleErrors.push(errorInfo);
                
                // Store in localStorage
                try {
                    const storedErrors = JSON.parse(localStorage.getItem('oauth_console_errors') || '[]');
                    storedErrors.push(errorInfo);
                    if (storedErrors.length > 100) {
                        storedErrors.shift();
                    }
                    localStorage.setItem('oauth_console_errors', JSON.stringify(storedErrors));
                } catch (e) {
                    // Ignore
                }
            });
            
            // Capture unhandled promise rejections
            window.addEventListener('unhandledrejection', (event) => {
                const errorInfo = {
                    timestamp: Date.now(),
                    type: 'unhandled_promise_rejection',
                    message: event.reason?.message || String(event.reason),
                    reason: event.reason,
                    stack: event.reason?.stack,
                    url: window.location.href
                };
                
                errorMonitor.consoleErrors.push(errorInfo);
                
                // Store in localStorage
                try {
                    const storedErrors = JSON.parse(localStorage.getItem('oauth_console_errors') || '[]');
                    storedErrors.push(errorInfo);
                    if (storedErrors.length > 100) {
                        storedErrors.shift();
                    }
                    localStorage.setItem('oauth_console_errors', JSON.stringify(storedErrors));
                } catch (e) {
                    // Ignore
                }
            });
            
            // Monitor network requests
            const originalFetch = window.fetch;
            window.fetch = async function(...args) {
                const startTime = Date.now();
                const url = args[0];
                
                try {
                    const response = await originalFetch.apply(this, args);
                    const endTime = Date.now();
                    const latency = endTime - startTime;
                    
                    // Track auth-related requests
                    if (typeof url === 'string' && (
                        url.includes('auth') || 
                        url.includes('oauth') ||
                        url.includes('supabase') ||
                        url.includes('callback')
                    )) {
                        const networkInfo = {
                            timestamp: Date.now(),
                            type: 'network_request',
                            url: url,
                            method: args[1]?.method || 'GET',
                            status: response.status,
                            statusText: response.statusText,
                            latency: latency,
                            success: response.ok
                        };
                        
                        if (!response.ok) {
                            errorMonitor.networkErrors.push(networkInfo);
                            
                            // Store failed requests
                            try {
                                const storedNetwork = JSON.parse(localStorage.getItem('oauth_network_errors') || '[]');
                                storedNetwork.push(networkInfo);
                                if (storedNetwork.length > 100) {
                                    storedNetwork.shift();
                                }
                                localStorage.setItem('oauth_network_errors', JSON.stringify(storedNetwork));
                            } catch (e) {
                                // Ignore
                            }
                        }
                    }
                    
                    return response;
                } catch (error) {
                    const networkInfo = {
                        timestamp: Date.now(),
                        type: 'network_error',
                        url: url,
                        method: args[1]?.method || 'GET',
                        error: error.message,
                        stack: error.stack
                    };
                    
                    errorMonitor.networkErrors.push(networkInfo);
                    
                    // Store network errors
                    try {
                        const storedNetwork = JSON.parse(localStorage.getItem('oauth_network_errors') || '[]');
                        storedNetwork.push(networkInfo);
                        if (storedNetwork.length > 100) {
                            storedNetwork.shift();
                        }
                        localStorage.setItem('oauth_network_errors', JSON.stringify(storedNetwork));
                    } catch (e) {
                        // Ignore
                    }
                    
                    throw error;
                }
            };
        }

        function startErrorMonitoring() {
            const btn = document.getElementById('monitorBtn');
            if (errorMonitor.active) {
                // Stop monitoring
                errorMonitor.active = false;
                if (errorMonitor.originalConsoleError) {
                    console.error = errorMonitor.originalConsoleError;
                }
                if (errorMonitor.originalConsoleWarn) {
                    console.warn = errorMonitor.originalConsoleWarn;
                }
                btn.innerHTML = 'üëÅÔ∏è Start Monitoring';
                btn.classList.remove('success');
                addResult('Monitoring Stopped', '<div class="check-item info">Error monitoring stopped. Collected errors are still available in diagnostic report.</div>', 'section');
            } else {
                captureConsoleErrors();
                btn.innerHTML = '‚è∏Ô∏è Stop Monitoring';
                btn.classList.add('success');
                addResult('Monitoring Started', '<div class="check-item success">‚úì Real-time error monitoring active. Errors will be captured automatically.</div>', 'success');
            }
        }

        // Load stored errors on page load
        function loadStoredErrors() {
            try {
                const storedConsoleErrors = localStorage.getItem('oauth_console_errors');
                if (storedConsoleErrors) {
                    errorMonitor.consoleErrors = JSON.parse(storedConsoleErrors).slice(-50); // Last 50
                }
                
                const storedNetworkErrors = localStorage.getItem('oauth_network_errors');
                if (storedNetworkErrors) {
                    errorMonitor.networkErrors = JSON.parse(storedNetworkErrors).slice(-50); // Last 50
                }
            } catch (e) {
                console.warn('Could not load stored errors:', e);
            }
        }
        
        // Auto-start monitoring on page load
        captureConsoleErrors();
        loadStoredErrors();

        function updateProgress(current, total) {
            const progressBar = document.getElementById('progressBar');
            const progressFill = document.getElementById('progressFill');
            const percentage = Math.round((current / total) * 100);
            progressBar.style.display = 'block';
            progressFill.style.width = percentage + '%';
        }

        function addResult(title, content, type = 'section') {
            const resultsDiv = document.getElementById('results');
            const section = document.createElement('div');
            section.className = `section ${type}`;
            section.innerHTML = `<h2>${title}</h2>${content}`;
            resultsDiv.appendChild(section);
        }

        function clearResults() {
            document.getElementById('results').innerHTML = '';
            document.getElementById('summary').innerHTML = '';
            testResults = { total: 0, passed: 0, failed: 0, warnings: 0 };
            document.getElementById('progressBar').style.display = 'none';
        }

        function addCheckItem(content, type = 'info', collapsible = false) {
            const icon = type === 'success' ? '‚úì' : type === 'error' ? '‚úó' : type === 'warning' ? '‚ö†' : '‚Ñπ';
            const item = document.createElement('div');
            item.className = `check-item ${type}`;
            
            if (collapsible) {
                const header = document.createElement('div');
                header.className = 'collapsible';
                header.innerHTML = `<span class="check-item-content">${content}</span>`;
                header.onclick = () => {
                    const content = header.nextElementSibling;
                    content.classList.toggle('expanded');
                };
                item.appendChild(header);
                const collapsibleContent = document.createElement('div');
                collapsibleContent.className = 'collapsible-content';
                collapsibleContent.innerHTML = collapsible;
                item.appendChild(collapsibleContent);
            } else {
                item.innerHTML = `<span class="check-item-content">${content}</span>`;
            }
            
            return item.outerHTML;
        }

        function showSummary() {
            const summaryDiv = document.getElementById('summary');
            const passRate = testResults.total > 0 ? Math.round((testResults.passed / testResults.total) * 100) : 0;
            const statusClass = testResults.failed > 0 ? 'error' : testResults.warnings > 0 ? 'warning' : 'success';
            
            summaryDiv.innerHTML = `
                <div class="summary ${statusClass}">
                    <h3>üìä Diagnostic Summary</h3>
                    <div class="summary-item"><strong>Total Tests:</strong> ${testResults.total}</div>
                    <div class="summary-item"><strong>Passed:</strong> <span style="color: #28a745;">${testResults.passed}</span></div>
                    <div class="summary-item"><strong>Failed:</strong> <span style="color: #dc3545;">${testResults.failed}</span></div>
                    <div class="summary-item"><strong>Warnings:</strong> <span style="color: #ffc107;">${testResults.warnings}</span></div>
                    <div class="summary-item"><strong>Pass Rate:</strong> ${passRate}%</div>
                </div>
            `;
        }

        function recordResult(passed, hasWarnings = false) {
            testResults.total++;
            if (passed) {
                testResults.passed++;
            } else {
                testResults.failed++;
            }
            if (hasWarnings) {
                testResults.warnings++;
            }
        }

        async function runFullDiagnostic() {
            clearResults();
            const btn = document.getElementById('fullDiagnosticBtn');
            btn.disabled = true;
            btn.innerHTML = '<span class="spinner"></span> Running...';

            const tests = [
                { name: 'Configuration', fn: testConfiguration },
                { name: 'Supabase Connection', fn: testSupabaseConnection },
                { name: 'Storage Analysis', fn: testStorageAnalysis },
                { name: 'URL Hash Analysis', fn: testURLHashAnalysis },
                { name: 'OAuth URL Deep Analysis', fn: testOAuthURLDeepAnalysis },
                { name: 'OAuth Credential Validation', fn: testOAuthCredentialValidation },
                { name: 'Callback Exchange Simulation', fn: testCallbackExchangeSimulation },
                { name: 'Error Pattern Analysis', fn: testErrorPatternAnalysis },
                { name: 'Provider Configuration Check', fn: testProviderConfigurationCheck },
                { name: 'Redirect Loop Detection', fn: testRedirectLoops },
                { name: 'Session Analysis', fn: testSessionAnalysis },
                { name: 'Provider Endpoints', fn: testProviderEndpoints },
                { name: 'Callback URL Validation', fn: testCallbackURLValidation },
                { name: 'Network Timing', fn: testNetworkTiming },
                { name: 'Browser History Analysis', fn: testBrowserHistoryAnalysis },
                { name: 'Token Validation', fn: testTokenValidation },
                { name: 'Console Error Analysis', fn: testConsoleErrorAnalysis },
                { name: 'Network Error Analysis', fn: testNetworkErrorAnalysis },
                { name: 'OAuth Flow Tracking', fn: testOAuthFlowTracking }
            ];

            for (let i = 0; i < tests.length; i++) {
                updateProgress(i, tests.length);
                try {
                    await tests[i].fn();
                } catch (error) {
                    addResult(tests[i].name, `<div class="check-item error">Exception: ${error.message}</div>`, 'error');
                }
            }

            updateProgress(tests.length, tests.length);
            showSummary();
            showDetailedInstructions();

            btn.disabled = false;
            btn.innerHTML = 'üî¨ Run Full Diagnostic';
        }

        async function testConfiguration() {
            let html = '';
            let passed = true;

            if (!window.config) {
                html += addCheckItem('Configuration not loaded', 'error');
                recordResult(false);
                addResult('1. Configuration', html, 'error');
                return;
            }

            html += addCheckItem('Configuration loaded', 'success');
            recordResult(true);

            html += addCheckItem(`Supabase URL: <code>${window.config.supabaseUrl}</code>`, 'info');
            html += addCheckItem(`API Key: <code>${window.config.supabaseKey ? window.config.supabaseKey.substring(0, 30) + '...' : 'MISSING'}</code>`, window.config.supabaseKey ? 'info' : 'error');

            if (!window.config.supabaseUrl || !window.config.supabaseKey) {
                passed = false;
                recordResult(false);
            }

            // Check if config looks valid
            if (window.config.supabaseUrl && !window.config.supabaseUrl.includes('supabase.co')) {
                html += addCheckItem('Warning: Supabase URL format looks incorrect', 'warning');
                recordResult(true, true);
            }

            addResult('1. Configuration', html, passed ? 'success' : 'error');
        }

        async function testSupabaseConnection() {
            let html = '';
            let passed = true;

            if (!window.supabase) {
                html += addCheckItem('Supabase library not loaded', 'error');
                recordResult(false);
                addResult('2. Supabase Connection', html, 'error');
                return;
            }

            html += addCheckItem('Supabase library loaded', 'success');
            recordResult(true);

            try {
                const client = window.getOrCreateSupabaseClient ? window.getOrCreateSupabaseClient() : 
                               window.supabase.createClient(window.config.supabaseUrl, window.config.supabaseKey);

                if (!client) {
                    html += addCheckItem('Failed to create Supabase client', 'error');
                    recordResult(false);
                    addResult('2. Supabase Connection', html, 'error');
                    return;
                }

                html += addCheckItem('Supabase client created', 'success');
                recordResult(true);

                // Test network connection with timing
                const startTime = performance.now();
                const response = await fetch(`${window.config.supabaseUrl}/rest/v1/`, {
                    method: 'HEAD',
                    headers: { 'apikey': window.config.supabaseKey }
                });
                const endTime = performance.now();
                const latency = Math.round(endTime - startTime);

                if (response.ok || response.status === 404) {
                    html += addCheckItem(`Network connection OK (Status: ${response.status}, Latency: ${latency}ms)`, 'success');
                    recordResult(true);
                } else {
                    html += addCheckItem(`Unexpected status: ${response.status}`, 'error');
                    passed = false;
                    recordResult(false);
                }

                // Test auth endpoint specifically
                try {
                    const authResponse = await fetch(`${window.config.supabaseUrl}/auth/v1/health`, {
                        method: 'GET',
                        headers: { 'apikey': window.config.supabaseKey }
                    });
                    if (authResponse.ok || authResponse.status === 404) {
                        html += addCheckItem('Auth endpoint reachable', 'success');
                    } else {
                        html += addCheckItem(`Auth endpoint returned: ${authResponse.status}`, 'warning');
                        recordResult(true, true);
                    }
                } catch (e) {
                    html += addCheckItem('Could not reach auth endpoint (may be normal)', 'warning');
                    recordResult(true, true);
                }

            } catch (error) {
                html += addCheckItem(`Connection failed: ${error.message}`, 'error');
                passed = false;
                recordResult(false);
            }

            addResult('2. Supabase Connection', html, passed ? 'success' : 'error');
        }

        async function testStorageAnalysis() {
            let html = '';
            let passed = true;

            try {
                const storageKeys = Object.keys(localStorage);
                html += addCheckItem(`Total localStorage keys: ${storageKeys.length}`, 'info');

                const authKeys = storageKeys.filter(k => 
                    k.includes('auth') || 
                    k.includes('supabase') || 
                    k.includes('sb-') ||
                    k.includes('padelpals')
                );

                if (authKeys.length === 0) {
                    html += addCheckItem('No auth-related keys found in storage', 'warning');
                    recordResult(true, true);
                } else {
                    html += addCheckItem(`Auth-related keys found: ${authKeys.length}`, 'info');
                    recordResult(true);

                    // Analyze each key
                    let hasStaleTokens = false;
                    let hasErrors = false;
                    let detailedAnalysis = '';

                    for (const key of authKeys) {
                        const value = localStorage.getItem(key);
                        try {
                            const parsed = JSON.parse(value);
                            
                            // Check for expired tokens
                            if (parsed.expires_at) {
                                const expiresAt = parsed.expires_at;
                                const now = Math.floor(Date.now() / 1000);
                                const isExpired = expiresAt < now;
                                
                                if (isExpired) {
                                    hasStaleTokens = true;
                                    detailedAnalysis += `<div><strong>${key}</strong>: Token expired ${Math.round((now - expiresAt) / 3600)} hours ago</div>`;
                                } else {
                                    const hoursUntilExpiry = Math.round((expiresAt - now) / 3600);
                                    detailedAnalysis += `<div><strong>${key}</strong>: Expires in ${hoursUntilExpiry} hours</div>`;
                                }
                            }

                            // Check for error messages
                            if (parsed.error || parsed.error_description) {
                                hasErrors = true;
                                detailedAnalysis += `<div><strong>${key}</strong>: Contains error - ${parsed.error || parsed.error_description}</div>`;
                            }

                            // Check for access/refresh tokens
                            if (parsed.access_token || parsed.refresh_token) {
                                detailedAnalysis += `<div><strong>${key}</strong>: Contains tokens</div>`;
                            }
                        } catch (e) {
                            // Not JSON, just show preview
                            if (value && value.length > 100) {
                                detailedAnalysis += `<div><strong>${key}</strong>: ${value.substring(0, 100)}...</div>`;
                            }
                        }
                    }

                    if (hasStaleTokens) {
                        html += addCheckItem('‚ö† Stale/expired tokens found in storage', 'warning', detailedAnalysis);
                        recordResult(true, true);
                    }

                    if (hasErrors) {
                        html += addCheckItem('‚úó Error data found in storage', 'error', detailedAnalysis);
                        passed = false;
                        recordResult(false);
                    }

                    if (detailedAnalysis) {
                        html += addCheckItem('Storage analysis details', 'info', detailedAnalysis);
                    }
                }

                // Check sessionStorage
                const sessionKeys = Object.keys(sessionStorage);
                if (sessionKeys.length > 0) {
                    html += addCheckItem(`SessionStorage keys: ${sessionKeys.length}`, 'info');
                }

            } catch (error) {
                html += addCheckItem(`Storage analysis failed: ${error.message}`, 'error');
                recordResult(false);
            }

            addResult('3. Storage Analysis', html, passed ? 'success' : 'error');
        }

        async function testURLHashAnalysis() {
            let html = '';
            let passed = true;

            const hash = window.location.hash.substring(1);
            const params = new URLSearchParams(window.location.search);

            if (!hash && params.toString() === '') {
                html += addCheckItem('No URL hash or query parameters (normal if not on callback page)', 'info');
                recordResult(true);
                addResult('4. URL Hash Analysis', html, 'success');
                return;
            }

            // Check hash fragment
            if (hash) {
                html += addCheckItem('URL hash fragment detected', 'info');
                recordResult(true);

                const hashParams = new URLSearchParams(hash);
                
                const accessToken = hashParams.get('access_token');
                const refreshToken = hashParams.get('refresh_token');
                const error = hashParams.get('error');
                const errorDescription = hashParams.get('error_description');

                if (error) {
                    html += addCheckItem(`‚ùå OAuth error in URL: ${error}`, 'error');
                    if (errorDescription) {
                        html += addCheckItem(`Error description: ${errorDescription}`, 'error');
                    }
                    passed = false;
                    recordResult(false);
                } else if (accessToken) {
                    html += addCheckItem('‚úì Access token found in URL hash', 'success');
                    recordResult(true);
                    
                    if (refreshToken) {
                        html += addCheckItem('‚úì Refresh token found in URL hash', 'success');
                    } else {
                        html += addCheckItem('‚ö† No refresh token in URL hash', 'warning');
                        recordResult(true, true);
                    }

                    // Analyze token
                    try {
                        const tokenParts = accessToken.split('.');
                        if (tokenParts.length === 3) {
                            const payload = JSON.parse(atob(tokenParts[1]));
                            const expiresAt = payload.exp;
                            const now = Math.floor(Date.now() / 1000);
                            
                            if (expiresAt < now) {
                                html += addCheckItem('‚ùå Access token is expired', 'error');
                                passed = false;
                                recordResult(false);
                            } else {
                                const minutesUntilExpiry = Math.round((expiresAt - now) / 60);
                                html += addCheckItem(`Token expires in ${minutesUntilExpiry} minutes`, 'info');
                            }
                        }
                    } catch (e) {
                        html += addCheckItem('Could not parse token', 'warning');
                        recordResult(true, true);
                    }
                } else {
                    html += addCheckItem('‚ö† URL hash present but no access_token found', 'warning');
                    recordResult(true, true);
                }
            }

            // Check query parameters for errors
            const queryError = params.get('error');
            if (queryError) {
                html += addCheckItem(`‚ùå Error in query parameters: ${queryError}`, 'error');
                passed = false;
                recordResult(false);
            }

            addResult('4. URL Hash Analysis', html, passed ? 'success' : 'error');
        }

        async function testOAuthURLDeepAnalysis() {
            let html = '';
            let passed = true;

            try {
                const client = window.getOrCreateSupabaseClient ? window.getOrCreateSupabaseClient() : 
                               window.supabase.createClient(window.config.supabaseUrl, window.config.supabaseKey);

                if (!client) {
                    html += addCheckItem('Cannot create Supabase client', 'error');
                    recordResult(false);
                    addResult('5. OAuth URL Deep Analysis', html, 'error');
                    return;
                }

                html += addCheckItem(`Expected website redirect: <code>${WEBSITE_CALLBACK_URL}</code>`, 'info');
                html += addCheckItem(`Supabase callback URL: <code>${SUPABASE_CALLBACK_URL}</code>`, 'info');

                // Test Google OAuth
                const googleResult = await client.auth.signInWithOAuth({
                    provider: 'google',
                    options: {
                        redirectTo: WEBSITE_CALLBACK_URL,
                        skipBrowserRedirect: true
                    }
                });

                if (googleResult.error) {
                    html += addCheckItem(`‚ùå Google OAuth Error: ${googleResult.error.message}`, 'error');
                    
                    if (googleResult.error.message.includes('exchange') || googleResult.error.message.includes('code')) {
                        html += addCheckItem('üîç This indicates OAuth credentials mismatch in Supabase', 'error');
                    }
                    if (googleResult.error.message.includes('redirect_uri')) {
                        html += addCheckItem('üîç Redirect URI not configured in Google Cloud Console', 'error');
                    }
                    passed = false;
                    recordResult(false);
                } else if (googleResult.data?.url) {
                    html += addCheckItem('‚úì Google OAuth URL generated successfully', 'success');
                    recordResult(true);

                    // Deep analysis of the OAuth URL
                    try {
                        const oauthUrl = new URL(googleResult.data.url);
                        const clientId = oauthUrl.searchParams.get('client_id');
                        const redirectUri = oauthUrl.searchParams.get('redirect_uri');
                        const responseType = oauthUrl.searchParams.get('response_type');
                        const scope = oauthUrl.searchParams.get('scope');

                        if (clientId) {
                            html += addCheckItem(`Google Client ID in URL: <code>${clientId.substring(0, 30)}...</code>`, 'info');
                        }

                        if (redirectUri) {
                            html += addCheckItem(`Redirect URI in OAuth URL: <code>${redirectUri}</code>`, 'info');
                            
                            if (redirectUri === SUPABASE_CALLBACK_URL) {
                                html += addCheckItem('‚úì Redirect URI matches Supabase callback', 'success');
                            } else {
                                html += addCheckItem('‚ö† Redirect URI mismatch', 'warning');
                                recordResult(true, true);
                            }
                        }

                        if (responseType) {
                            html += addCheckItem(`Response type: ${responseType}`, 'info');
                        }

                        if (scope) {
                            html += addCheckItem(`Scopes: ${scope}`, 'info');
                        }
                    } catch (e) {
                        html += addCheckItem('Could not parse OAuth URL', 'warning');
                        recordResult(true, true);
                    }
                } else {
                    html += addCheckItem('‚ùå No Google OAuth URL returned', 'error');
                    passed = false;
                    recordResult(false);
                }

                // Test Apple OAuth
                const appleResult = await client.auth.signInWithOAuth({
                    provider: 'apple',
                    options: {
                        redirectTo: WEBSITE_CALLBACK_URL,
                        skipBrowserRedirect: true
                    }
                });

                if (appleResult.error) {
                    html += addCheckItem(`‚ùå Apple OAuth Error: ${appleResult.error.message}`, 'error');
                    
                    if (appleResult.error.message.includes('exchange') || appleResult.error.message.includes('code')) {
                        html += addCheckItem('üîç This indicates OAuth credentials mismatch in Supabase', 'error');
                    }
                    if (appleResult.error.message.includes('redirect_uri')) {
                        html += addCheckItem('üîç Return URL not configured in Apple Developer Portal', 'error');
                    }
                    passed = false;
                    recordResult(false);
                } else if (appleResult.data?.url) {
                    html += addCheckItem('‚úì Apple OAuth URL generated successfully', 'success');
                    recordResult(true);
                } else {
                    html += addCheckItem('‚ùå No Apple OAuth URL returned', 'error');
                    passed = false;
                    recordResult(false);
                }

            } catch (error) {
                html += addCheckItem(`Exception: ${error.message}`, 'error');
                passed = false;
                recordResult(false);
            }

            addResult('5. OAuth URL Deep Analysis', html, passed ? 'success' : 'error');
        }

        async function testRedirectLoops() {
            let html = '';
            let passed = true;

            try {
                // Check for redirect time in localStorage
                const redirectTime = localStorage.getItem('authRedirectTime');
                if (redirectTime) {
                    const timeDiff = Date.now() - parseInt(redirectTime);
                    const minutesAgo = Math.round(timeDiff / 60000);
                    
                    if (minutesAgo < 5) {
                        html += addCheckItem(`‚ö† Recent redirect detected (${minutesAgo} minutes ago)`, 'warning');
                        recordResult(true, true);
                    } else {
                        html += addCheckItem(`Last redirect: ${minutesAgo} minutes ago`, 'info');
                    }
                } else {
                    html += addCheckItem('No redirect time stored (normal)', 'info');
                }

                // Check browser history for loops
                const currentUrl = window.location.href;
                const isOnAuthPage = currentUrl.includes('auth.html');
                const isOnCallbackPage = currentUrl.includes('auth-callback.html');
                const isOnDashboard = currentUrl.includes('dashboard.html');

                if (isOnCallbackPage) {
                    html += addCheckItem('Currently on callback page', 'info');
                } else if (isOnAuthPage) {
                    html += addCheckItem('Currently on auth page', 'info');
                } else if (isOnDashboard) {
                    html += addCheckItem('Currently on dashboard', 'info');
                }

                // Check for multiple recent navigations
                if (performance.getEntriesByType('navigation').length > 0) {
                    const navEntry = performance.getEntriesByType('navigation')[0];
                    if (navEntry.type === 'reload' && redirectTime && Date.now() - parseInt(redirectTime) < 30000) {
                        html += addCheckItem('‚ö† Possible redirect loop detected (recent redirect and reload)', 'warning');
                        recordResult(true, true);
                    }
                }

            } catch (error) {
                html += addCheckItem(`Redirect loop check failed: ${error.message}`, 'error');
                recordResult(false);
            }

            addResult('10. Redirect Loop Detection', html, passed ? 'success' : 'warning');
        }

        async function testSessionAnalysis() {
            let html = '';
            let passed = true;

            try {
                const client = window.getOrCreateSupabaseClient ? window.getOrCreateSupabaseClient() : 
                               window.supabase.createClient(window.config.supabaseUrl, window.config.supabaseKey);

                if (!client) {
                    html += addCheckItem('Cannot create Supabase client', 'error');
                    recordResult(false);
                    addResult('7. Session Analysis', html, 'error');
                    return;
                }

                const { data: { session }, error } = await client.auth.getSession();

                if (error) {
                    html += addCheckItem(`‚ùå Session error: ${error.message}`, 'error');
                    passed = false;
                    recordResult(false);
                } else if (session) {
                    html += addCheckItem('‚úì Active session found', 'success');
                    recordResult(true);
                    html += addCheckItem(`User ID: <code>${session.user.id}</code>`, 'info');
                    html += addCheckItem(`Email: <code>${session.user.email || 'N/A'}</code>`, 'info');
                    html += addCheckItem(`Provider: ${session.user.app_metadata?.provider || 'unknown'}`, 'info');
                    
                    const now = Math.floor(Date.now() / 1000);
                    if (session.expires_at < now) {
                        html += addCheckItem('‚ùå Session is EXPIRED', 'error');
                        passed = false;
                        recordResult(false);
                    } else {
                        const hoursUntilExpiry = Math.round((session.expires_at - now) / 3600);
                        html += addCheckItem(`Session expires in ${hoursUntilExpiry} hours`, 'info');
                        html += addCheckItem(`Expires at: ${new Date(session.expires_at * 1000).toLocaleString()}`, 'info');
                    }
                } else {
                    html += addCheckItem('No active session (user not signed in)', 'warning');
                    recordResult(true, true);
                }

            } catch (error) {
                html += addCheckItem(`Exception: ${error.message}`, 'error');
                passed = false;
                recordResult(false);
            }

            addResult('11. Session Analysis', html, passed ? 'success' : 'error');
        }

        async function testProviderEndpoints() {
            let html = '';
            let passed = true;

            try {
                // Test if we can reach Supabase auth endpoints
                const endpoints = [
                    '/auth/v1/health',
                    '/auth/v1/settings',
                ];

                for (const endpoint of endpoints) {
                    try {
                        const response = await fetch(`${SUPABASE_URL}${endpoint}`, {
                            method: 'GET',
                            headers: {
                                'apikey': window.config?.supabaseKey || ''
                            }
                        });

                        if (response.ok || response.status === 404 || response.status === 401) {
                            // 401 is expected for protected endpoints without auth
                            html += addCheckItem(`Endpoint ${endpoint}: Status ${response.status}`, 'info');
                        } else {
                            html += addCheckItem(`Endpoint ${endpoint}: Unexpected status ${response.status}`, 'warning');
                            recordResult(true, true);
                        }
                    } catch (e) {
                        html += addCheckItem(`Endpoint ${endpoint}: ${e.message}`, 'warning');
                        recordResult(true, true);
                    }
                }

            } catch (error) {
                html += addCheckItem(`Provider endpoint test failed: ${error.message}`, 'error');
                recordResult(false);
            }

            addResult('12. Provider Endpoints', html, passed ? 'success' : 'warning');
        }

        async function testCallbackURLValidation() {
            let html = '';
            let passed = true;

            html += addCheckItem(`Expected callback URL: <code>${WEBSITE_CALLBACK_URL}</code>`, 'info');
            html += addCheckItem(`Supabase callback URL: <code>${SUPABASE_CALLBACK_URL}</code>`, 'info');

            // Check if callback URL is accessible
            try {
                const response = await fetch(WEBSITE_CALLBACK_URL, { method: 'HEAD' });
                if (response.ok || response.status === 200) {
                    html += addCheckItem('‚úì Callback page is accessible', 'success');
                    recordResult(true);
                } else {
                    html += addCheckItem(`‚ö† Callback page returned status: ${response.status}`, 'warning');
                    recordResult(true, true);
                }
            } catch (error) {
                html += addCheckItem(`‚ö† Could not verify callback page accessibility: ${error.message}`, 'warning');
                recordResult(true, true);
            }

            // Validate URL format
            try {
                const callbackUrl = new URL(WEBSITE_CALLBACK_URL);
                if (callbackUrl.protocol === 'https:') {
                    html += addCheckItem('‚úì Callback URL uses HTTPS', 'success');
                } else {
                    html += addCheckItem('‚ùå Callback URL should use HTTPS', 'error');
                    passed = false;
                    recordResult(false);
                }
            } catch (e) {
                html += addCheckItem(`‚ùå Callback URL format invalid: ${e.message}`, 'error');
                passed = false;
                recordResult(false);
            }

            addResult('13. Callback URL Validation', html, passed ? 'success' : 'error');
        }

        async function testNetworkTiming() {
            let html = '';
            let passed = true;

            try {
                // Test Supabase latency
                const startTime = performance.now();
                await fetch(`${window.config.supabaseUrl}/rest/v1/`, {
                    method: 'HEAD',
                    headers: { 'apikey': window.config.supabaseKey }
                });
                const latency = Math.round(performance.now() - startTime);

                html += addCheckItem(`Supabase latency: ${latency}ms`, latency < 500 ? 'success' : latency < 1000 ? 'warning' : 'error');
                
                if (latency > 1000) {
                    html += addCheckItem('‚ö† High latency detected - may affect OAuth flow', 'warning');
                    recordResult(true, true);
                } else {
                    recordResult(true);
                }

            } catch (error) {
                html += addCheckItem(`Network timing test failed: ${error.message}`, 'error');
                recordResult(false);
            }

            addResult('14. Network Timing', html, passed ? 'success' : 'error');
        }

        async function testOAuthCredentialValidation() {
            let html = '';
            let passed = true;

            try {
                const client = window.getOrCreateSupabaseClient ? window.getOrCreateSupabaseClient() : 
                               window.supabase.createClient(window.config.supabaseUrl, window.config.supabaseKey);

                if (!client) {
                    html += addCheckItem('Cannot create Supabase client', 'error');
                    recordResult(false);
                    addResult('6. OAuth Credential Validation', html, 'error');
                    return;
                }

                html += addCheckItem('üîç Analyzing OAuth URLs for credential information...', 'info');

                // Generate Google OAuth URL and extract credentials info
                const googleResult = await client.auth.signInWithOAuth({
                    provider: 'google',
                    options: {
                        redirectTo: WEBSITE_CALLBACK_URL,
                        skipBrowserRedirect: true
                    }
                });

                if (googleResult.data?.url) {
                    try {
                        const googleUrl = new URL(googleResult.data.url);
                        const googleClientId = googleUrl.searchParams.get('client_id');
                        
                        if (googleClientId) {
                            html += addCheckItem(`‚úì Google Client ID extracted: <code>${googleClientId.substring(0, 30)}...</code>`, 'success');
                            recordResult(true);
                            
                            // Validate Client ID format
                            if (googleClientId.includes('.apps.googleusercontent.com')) {
                                html += addCheckItem('‚úì Google Client ID format is valid', 'success');
                            } else {
                                html += addCheckItem('‚ö† Google Client ID format looks unusual', 'warning');
                                recordResult(true, true);
                            }

                            // Check redirect URI in URL
                            const redirectUri = googleUrl.searchParams.get('redirect_uri');
                            if (redirectUri) {
                                if (redirectUri === SUPABASE_CALLBACK_URL) {
                                    html += addCheckItem('‚úì Redirect URI matches Supabase callback URL', 'success');
                                } else {
                                    html += addCheckItem(`‚ö† Redirect URI mismatch: <code>${redirectUri}</code> (expected: <code>${SUPABASE_CALLBACK_URL}</code>)`, 'warning');
                                    recordResult(true, true);
                                    passed = false;
                                }
                            }
                        }
                    } catch (e) {
                        html += addCheckItem(`‚ö† Could not analyze Google OAuth URL: ${e.message}`, 'warning');
                        recordResult(true, true);
                    }
                }

                // Generate Apple OAuth URL
                const appleResult = await client.auth.signInWithOAuth({
                    provider: 'apple',
                    options: {
                        redirectTo: WEBSITE_CALLBACK_URL,
                        skipBrowserRedirect: true
                    }
                });

                if (appleResult.data?.url) {
                    try {
                        const appleUrl = new URL(appleResult.data.url);
                        const appleClientId = appleUrl.searchParams.get('client_id');
                        
                        if (appleClientId) {
                            html += addCheckItem(`‚úì Apple Services ID extracted: <code>${appleClientId}</code>`, 'success');
                            recordResult(true);
                            
                            // Check redirect URI
                            const redirectUri = appleUrl.searchParams.get('redirect_uri');
                            if (redirectUri) {
                                if (redirectUri === SUPABASE_CALLBACK_URL) {
                                    html += addCheckItem('‚úì Apple redirect URI matches Supabase callback', 'success');
                                } else {
                                    html += addCheckItem(`‚ö† Apple redirect URI mismatch`, 'warning');
                                    recordResult(true, true);
                                    passed = false;
                                }
                            }
                        }
                    } catch (e) {
                        html += addCheckItem(`‚ö† Could not analyze Apple OAuth URL: ${e.message}`, 'warning');
                        recordResult(true, true);
                    }
                }

                // Test if we can reach OAuth provider endpoints (indirect validation)
                html += addCheckItem('üîç Testing OAuth provider endpoints...', 'info');
                
                try {
                    // Google OAuth endpoint test
                    const googleTest = await fetch('https://accounts.google.com/.well-known/openid-configuration', {
                        method: 'HEAD'
                    });
                    if (googleTest.ok || googleTest.status === 200) {
                        html += addCheckItem('‚úì Google OAuth endpoint reachable', 'success');
                    }
                } catch (e) {
                    html += addCheckItem('‚ö† Could not reach Google OAuth endpoint', 'warning');
                    recordResult(true, true);
                }

            } catch (error) {
                html += addCheckItem(`Credential validation failed: ${error.message}`, 'error');
                passed = false;
                recordResult(false);
            }

            addResult('6. OAuth Credential Validation', html, passed ? 'success' : 'warning');
        }

        async function testCallbackExchangeSimulation() {
            let html = '';
            let passed = true;

            try {
                html += addCheckItem('üîç Simulating OAuth callback exchange...', 'info');

                const client = window.getOrCreateSupabaseClient ? window.getOrCreateSupabaseClient() : 
                               window.supabase.createClient(window.config.supabaseUrl, window.config.supabaseKey);

                if (!client) {
                    html += addCheckItem('Cannot create Supabase client', 'error');
                    recordResult(false);
                    addResult('7. Callback Exchange Simulation', html, 'error');
                    return;
                }

                // Check if we're currently on a callback page
                const isOnCallbackPage = window.location.pathname.includes('auth-callback.html');
                const hash = window.location.hash.substring(1);

                if (isOnCallbackPage && hash) {
                    html += addCheckItem('‚úì Currently on callback page with hash fragment', 'success');
                    recordResult(true);

                    const hashParams = new URLSearchParams(hash);
                    const accessToken = hashParams.get('access_token');
                    const refreshToken = hashParams.get('refresh_token');
                    const error = hashParams.get('error');

                    if (error) {
                        html += addCheckItem(`‚ùå Error in callback: ${error}`, 'error');
                        html += addCheckItem(`Error description: ${hashParams.get('error_description') || 'None'}`, 'error');
                        
                        // Analyze error type
                        if (error.includes('access_denied')) {
                            html += addCheckItem('üîç Error suggests user denied authorization', 'info');
                        } else if (error.includes('invalid_request')) {
                            html += addCheckItem('üîç Error suggests invalid OAuth request - check credentials', 'error');
                            passed = false;
                            recordResult(false);
                        } else if (error.includes('server_error')) {
                            html += addCheckItem('üîç Error suggests server error - likely credentials mismatch', 'error');
                            passed = false;
                            recordResult(false);
                        }
                    } else if (accessToken) {
                        html += addCheckItem('‚úì Access token received in callback', 'success');
                        recordResult(true);

                        // Try to set the session
                        try {
                            const { error: setError } = await client.auth.setSession({
                                access_token: accessToken,
                                refresh_token: refreshToken
                            });

                            if (setError) {
                                html += addCheckItem(`‚ùå Failed to set session: ${setError.message}`, 'error');
                                
                                if (setError.message.includes('expired') || setError.message.includes('invalid')) {
                                    html += addCheckItem('üîç Token appears invalid or expired - check OAuth credentials', 'error');
                                }
                                passed = false;
                                recordResult(false);
                            } else {
                                html += addCheckItem('‚úì Session set successfully (simulation)', 'success');
                                recordResult(true);
                            }
                        } catch (e) {
                            html += addCheckItem(`‚ö† Could not test session setting: ${e.message}`, 'warning');
                            recordResult(true, true);
                        }
                    } else {
                        html += addCheckItem('‚ö† On callback page but no tokens or errors found', 'warning');
                        recordResult(true, true);
                    }
                } else {
                    html += addCheckItem('Not on callback page - cannot simulate exchange', 'info');
                    html += addCheckItem('üí° Try clicking "Test OAuth Flow" to trigger actual callback', 'info');
                    recordResult(true);
                }

            } catch (error) {
                html += addCheckItem(`Callback exchange simulation failed: ${error.message}`, 'error');
                passed = false;
                recordResult(false);
            }

            addResult('7. Callback Exchange Simulation', html, passed ? 'success' : 'error');
        }

        async function testErrorPatternAnalysis() {
            let html = '';
            let passed = true;
            const errorsFound = [];

            try {
                html += addCheckItem('üîç Analyzing patterns from previous authentication attempts...', 'info');

                // Check for stored callback errors (from auth-callback.html)
                try {
                    const lastError = localStorage.getItem('oauth_last_error');
                    if (lastError) {
                        const errorInfo = JSON.parse(lastError);
                        errorsFound.push({
                            key: 'CALLBACK_ERROR',
                            error: `${errorInfo.message}`,
                            timestamp: new Date(errorInfo.timestamp).toLocaleString(),
                            type: errorInfo.errorType || 'unknown',
                            url: errorInfo.url,
                            details: errorInfo
                        });
                    }

                    const diagnosticErrors = localStorage.getItem('oauth_diagnostic_errors');
                    if (diagnosticErrors) {
                        const errorList = JSON.parse(diagnosticErrors);
                        errorList.forEach((err, idx) => {
                            if (idx > 0 || !lastError) { // Avoid duplicates
                                errorsFound.push({
                                    key: `CALLBACK_ERROR_${idx}`,
                                    error: `${err.message}`,
                                    timestamp: new Date(err.timestamp).toLocaleString(),
                                    type: err.errorType || 'unknown',
                                    url: err.url,
                                    details: err
                                });
                            }
                        });
                    }

                    // Check for callback data
                    const lastCallback = localStorage.getItem('oauth_last_callback');
                    if (lastCallback) {
                        const callbackInfo = JSON.parse(lastCallback);
                        if (!callbackInfo.hasHash && !errorsFound.find(e => e.key.includes('CALLBACK'))) {
                            errorsFound.push({
                                key: 'CALLBACK_NO_HASH',
                                error: 'Callback page reached but no hash fragment in URL',
                                timestamp: new Date(callbackInfo.timestamp).toLocaleString(),
                                type: 'callback_missing_data'
                            });
                        }
                    }

                    const callbackParams = localStorage.getItem('oauth_callback_params');
                    if (callbackParams) {
                        const params = JSON.parse(callbackParams);
                        if (params.error && !errorsFound.find(e => e.error.includes(params.error))) {
                            errorsFound.push({
                                key: 'CALLBACK_PARAMS_ERROR',
                                error: `${params.error}: ${params.errorDescription || ''}`,
                                timestamp: new Date(params.timestamp).toLocaleString(),
                                type: 'oauth_provider_error',
                                details: params
                            });
                        }
                    }
                } catch (e) {
                    html += addCheckItem(`‚ö† Could not parse stored callback errors: ${e.message}`, 'warning');
                    recordResult(true, true);
                }

                // Check localStorage for error patterns
                const storageKeys = Object.keys(localStorage);
                const authKeys = storageKeys.filter(k => 
                    k.includes('auth') || k.includes('supabase') || k.includes('sb-') || k.includes('error')
                );

                for (const key of authKeys) {
                    const value = localStorage.getItem(key);
                    try {
                        const parsed = JSON.parse(value);
                        
                        if (parsed.error || parsed.error_description) {
                            errorsFound.push({
                                key,
                                error: parsed.error || parsed.error_description,
                                timestamp: parsed.timestamp || 'unknown'
                            });
                        }
                    } catch (e) {
                        // Check if value contains error strings
                        if (value && (value.toLowerCase().includes('error') || value.toLowerCase().includes('failed'))) {
                            errorsFound.push({
                                key,
                                error: value.substring(0, 100),
                                timestamp: 'unknown'
                            });
                        }
                    }
                }

                // Check URL parameters for errors
                const urlParams = new URLSearchParams(window.location.search);
                const urlHash = new URLSearchParams(window.location.hash.substring(1));
                
                if (urlParams.get('error')) {
                    errorsFound.push({
                        key: 'URL_QUERY',
                        error: `${urlParams.get('error')}: ${urlParams.get('error_description') || ''}`,
                        timestamp: 'current'
                    });
                }

                if (urlHash.get('error')) {
                    errorsFound.push({
                        key: 'URL_HASH',
                        error: `${urlHash.get('error')}: ${urlHash.get('error_description') || ''}`,
                        timestamp: 'current'
                    });
                }

                if (errorsFound.length > 0) {
                    // Sort errors by timestamp (most recent first)
                    errorsFound.sort((a, b) => {
                        const aTime = typeof a.timestamp === 'number' ? a.timestamp : 
                                     (a.timestamp === 'current' ? Date.now() : 0);
                        const bTime = typeof b.timestamp === 'number' ? b.timestamp : 
                                     (b.timestamp === 'current' ? Date.now() : 0);
                        return bTime - aTime;
                    });
                    
                    html += addCheckItem(`‚ö† Found ${errorsFound.length} error pattern(s)`, 'warning');
                    recordResult(true, true);
                    passed = false;
                    
                    // Show the most recent error prominently
                    const mostRecentError = errorsFound[0];
                    if (mostRecentError.error) {
                        const errorMsg = mostRecentError.error.toLowerCase();
                        
                        if (errorMsg.includes('no authentication data') || errorMsg.includes('no hash fragment')) {
                            html += addCheckItem('üîç PRIMARY ISSUE DETECTED: "No authentication data in URL"', 'error');
                            html += addCheckItem('üí° This means: OAuth provider redirected back, but Supabase failed to exchange the authorization code', 'error');
                            html += addCheckItem('üí° Root Cause: OAuth credentials in Supabase don\'t match Google/Apple consoles', 'error');
                            html += addCheckItem('üìã Action Required:', 'error');
                            html += addCheckItem('1. Go to Supabase Dashboard ‚Üí Authentication ‚Üí Providers', 'info');
                            html += addCheckItem('2. For Google: Verify Client ID and Secret match Google Cloud Console EXACTLY', 'info');
                            html += addCheckItem('3. For Apple: Verify Services ID, Secret Key (.p8), Key ID, and Team ID match Apple Developer Portal EXACTLY', 'info');
                            html += addCheckItem('4. Ensure redirect URI in provider console is: <code>' + SUPABASE_CALLBACK_URL + '</code>', 'info');
                            html += addCheckItem('5. Save changes and wait 5-10 minutes for propagation', 'info');
                            recordResult(false);
                        }
                        
                        if (errorMsg.includes('exchange') || errorMsg.includes('external code')) {
                            html += addCheckItem('üîç PRIMARY ISSUE DETECTED: "Unable to exchange external code"', 'error');
                            html += addCheckItem('üí° Root Cause: OAuth credentials mismatch between Supabase and provider console', 'error');
                            html += addCheckItem('üìã Solution: Update OAuth credentials in Supabase to match provider consoles exactly', 'info');
                            recordResult(false);
                        }
                        
                        if (errorMsg.includes('redirect_uri') || errorMsg.includes('redirect uri')) {
                            html += addCheckItem('üîç PRIMARY ISSUE DETECTED: Redirect URI mismatch', 'error');
                            html += addCheckItem('üí° Root Cause: Redirect URI not configured in provider console', 'error');
                            html += addCheckItem('üìã Solution: Add <code>' + SUPABASE_CALLBACK_URL + '</code> to provider console redirect URIs', 'info');
                            recordResult(false);
                        }
                    }

                    let errorDetails = '<div style="background: #fff5f5; padding: 15px; border-radius: 8px; border: 2px solid #dc3545; margin-top: 10px;">';
                    errorDetails += '<h4 style="color: #dc3545; margin-top: 0;">üî¥ Detailed Error Information</h4>';
                    
                    errorsFound.forEach((err, idx) => {
                        const isRecent = idx < 3; // Highlight first 3 (most recent)
                        const bgColor = isRecent ? '#fff5f5' : '#fff';
                        const borderColor = isRecent ? '#dc3545' : '#ddd';
                        
                        errorDetails += `<div style="margin: 10px 0; padding: 12px; background: ${bgColor}; border-radius: 6px; border-left: 4px solid ${borderColor};">`;
                        errorDetails += `<strong style="color: #dc3545;">${idx + 1}. ${err.key || 'ERROR'}</strong><br>`;
                        errorDetails += `<div style="margin: 5px 0; padding: 8px; background: #fff; border-radius: 4px; font-family: monospace; word-break: break-all;">${err.error}</div>`;
                        
                        // Show timestamp
                        let timeStr = err.timestamp;
                        if (typeof err.timestamp === 'number') {
                            timeStr = new Date(err.timestamp).toLocaleString();
                        } else if (err.timestamp === 'current') {
                            timeStr = 'Current session';
                        }
                        errorDetails += `<small style="color: #666;">‚è∞ Time: ${timeStr}</small>`;
                        
                        if (err.type) {
                            errorDetails += `<br><small style="color: #666;">üìÅ Type: ${err.type}</small>`;
                        }
                        
                        if (err.url) {
                            const displayUrl = err.url.length > 100 ? err.url.substring(0, 100) + '...' : err.url;
                            errorDetails += `<br><small style="color: #666;">üîó URL: <code style="word-break: break-all;">${displayUrl}</code></small>`;
                        }
                        
                        // Show full details for most recent errors
                        if (isRecent && err.details && typeof err.details === 'object') {
                            try {
                                const detailsStr = JSON.stringify(err.details, null, 2);
                                errorDetails += `<br><details style="margin-top: 8px;"><summary style="cursor: pointer; color: #4A90E2; font-weight: bold;">üìÑ View Full Details</summary>`;
                                errorDetails += `<pre style="font-size: 0.85em; overflow-x: auto; background: #f8f9fa; padding: 10px; border-radius: 4px; margin-top: 5px; max-height: 300px; overflow-y: auto;">${detailsStr}</pre></details>`;
                            } catch (e) {
                                // Skip if can't stringify
                            }
                        }
                        
                        // Extract specific error information
                        if (err.details) {
                            if (err.details.message) {
                                errorDetails += `<br><div style="margin-top: 5px; padding: 5px; background: #fff3cd; border-radius: 4px; font-size: 0.9em;">üí¨ Message: <code>${err.details.message}</code></div>`;
                            }
                            if (err.details.errorType) {
                                errorDetails += `<br><small style="color: #666;">üè∑Ô∏è Error Type: ${err.details.errorType}</small>`;
                            }
                        }
                        
                        errorDetails += `</div>`;
                    });
                    
                    errorDetails += '</div>';
                    
                    html += addCheckItem('Complete Error History', 'error', errorDetails);

                    // Analyze common error patterns
                    const allErrors = errorsFound.map(e => e.error.toLowerCase()).join(' ');
                    
                    if (allErrors.includes('exchange') || allErrors.includes('code')) {
                        html += addCheckItem('üîç Pattern detected: "exchange" or "code" errors - likely OAuth credentials mismatch', 'error');
                        html += addCheckItem('üí° Root Cause: Supabase cannot exchange authorization code for tokens', 'error');
                        html += addCheckItem('üí° Action: Update Client ID/Secret in Supabase Dashboard ‚Üí Authentication ‚Üí Providers', 'info');
                        html += addCheckItem('üí° Verify: Credentials in Supabase must EXACTLY match Google/Apple consoles', 'info');
                        passed = false;
                        recordResult(false);
                    }
                    
                    if (allErrors.includes('redirect_uri') || allErrors.includes('redirect uri')) {
                        html += addCheckItem('üîç Pattern detected: Redirect URI errors - check redirect URIs in Google/Apple consoles', 'error');
                        html += addCheckItem('üí° Root Cause: Redirect URI in provider console does not match Supabase callback', 'error');
                        html += addCheckItem(`üí° Action: Ensure <code>${SUPABASE_CALLBACK_URL}</code> is configured in provider consoles`, 'info');
                        passed = false;
                        recordResult(false);
                    }
                    
                    if (allErrors.includes('expired') || allErrors.includes('invalid')) {
                        html += addCheckItem('üîç Pattern detected: Expired or invalid tokens - credentials may have expired', 'error');
                        html += addCheckItem('üí° Root Cause: OAuth credentials (especially Apple Secret Keys) may have expired', 'error');
                        html += addCheckItem('üí° Action: Regenerate OAuth credentials and update Supabase', 'info');
                        passed = false;
                        recordResult(false);
                    }

                    // Check for "no hash fragment" errors
                    if (allErrors.includes('no hash') || allErrors.includes('no hash fragment')) {
                        html += addCheckItem('üîç Pattern detected: No hash fragment in callback URL', 'error');
                        html += addCheckItem('üí° Root Cause: OAuth provider did not redirect with tokens - credentials likely invalid', 'error');
                        html += addCheckItem('üí° Action: Check OAuth credentials in Supabase match provider consoles exactly', 'info');
                        passed = false;
                        recordResult(false);
                    }

                    // Check for "no access token" errors
                    if (allErrors.includes('no access token')) {
                        html += addCheckItem('üîç Pattern detected: No access token received from OAuth provider', 'error');
                        html += addCheckItem('üí° Root Cause: OAuth provider redirect did not include tokens - likely credentials mismatch', 'error');
                        html += addCheckItem('üí° Action: Verify OAuth credentials in Supabase Dashboard match provider consoles', 'info');
                        passed = false;
                        recordResult(false);
                    }
                } else {
                    html += addCheckItem('‚úì No error patterns found in storage or URL', 'success');
                    recordResult(true);
                }

            } catch (error) {
                html += addCheckItem(`Error pattern analysis failed: ${error.message}`, 'error');
                recordResult(false);
            }

            addResult('8. Error Pattern Analysis', html, passed ? 'success' : 'warning');
        }

        async function testProviderConfigurationCheck() {
            let html = '';
            let passed = true;

            try {
                html += addCheckItem('üîç Checking provider configuration via Supabase API...', 'info');

                const client = window.getOrCreateSupabaseClient ? window.getOrCreateSupabaseClient() : 
                               window.supabase.createClient(window.config.supabaseUrl, window.config.supabaseKey);

                if (!client) {
                    html += addCheckItem('Cannot create Supabase client', 'error');
                    recordResult(false);
                    addResult('9. Provider Configuration Check', html, 'error');
                    return;
                }

                // Try to get provider settings (may not be available via API, but we can infer from OAuth URLs)
                html += addCheckItem('üí° Provider configuration can only be verified by checking generated OAuth URLs', 'info');

                // Generate OAuth URLs to check if providers are enabled
                const googleResult = await client.auth.signInWithOAuth({
                    provider: 'google',
                    options: {
                        redirectTo: WEBSITE_CALLBACK_URL,
                        skipBrowserRedirect: true
                    }
                });

                if (googleResult.error) {
                    if (googleResult.error.message.includes('not enabled') || googleResult.error.message.includes('disabled')) {
                        html += addCheckItem('‚ùå Google provider appears to be disabled in Supabase', 'error');
                        passed = false;
                        recordResult(false);
                    } else {
                        html += addCheckItem(`‚ö† Google OAuth error: ${googleResult.error.message}`, 'warning');
                        recordResult(true, true);
                    }
                } else if (googleResult.data?.url) {
                    html += addCheckItem('‚úì Google provider appears to be enabled', 'success');
                    recordResult(true);
                }

                const appleResult = await client.auth.signInWithOAuth({
                    provider: 'apple',
                    options: {
                        redirectTo: WEBSITE_CALLBACK_URL,
                        skipBrowserRedirect: true
                    }
                });

                if (appleResult.error) {
                    if (appleResult.error.message.includes('not enabled') || appleResult.error.message.includes('disabled')) {
                        html += addCheckItem('‚ùå Apple provider appears to be disabled in Supabase', 'error');
                        passed = false;
                        recordResult(false);
                    } else {
                        html += addCheckItem(`‚ö† Apple OAuth error: ${appleResult.error.message}`, 'warning');
                        recordResult(true, true);
                    }
                } else if (appleResult.data?.url) {
                    html += addCheckItem('‚úì Apple provider appears to be enabled', 'success');
                    recordResult(true);
                }

                html += addCheckItem('üí° To verify credentials match exactly, compare values in Supabase Dashboard with Google/Apple consoles', 'info');

            } catch (error) {
                html += addCheckItem(`Provider configuration check failed: ${error.message}`, 'error');
                recordResult(false);
            }

            addResult('9. Provider Configuration Check', html, passed ? 'success' : 'warning');
        }

        async function testBrowserHistoryAnalysis() {
            let html = '';
            let passed = true;

            try {
                html += addCheckItem('üîç Analyzing browser navigation history...', 'info');

                // Check performance navigation timing
                const navEntries = performance.getEntriesByType('navigation');
                if (navEntries.length > 0) {
                    const navEntry = navEntries[0];
                    html += addCheckItem(`Navigation type: ${navEntry.type}`, 'info');

                    if (navEntry.type === 'reload') {
                        html += addCheckItem('Page was reloaded', 'info');
                    }

                    if (navEntry.redirectCount > 0) {
                        html += addCheckItem(`‚ö† ${navEntry.redirectCount} redirect(s) detected`, 'warning');
                        recordResult(true, true);
                    }
                }

                // Check session history length
                html += addCheckItem(`Session history length: ${history.length}`, 'info');

                // Check for auth-related URLs in history (indirect check)
                const currentUrl = window.location.href;
                if (currentUrl.includes('auth-callback.html')) {
                    html += addCheckItem('Currently on callback page', 'info');
                } else if (currentUrl.includes('auth.html')) {
                    html += addCheckItem('Currently on auth page', 'info');
                } else if (currentUrl.includes('oauth-diagnostic.html')) {
                    html += addCheckItem('Currently on diagnostic page', 'info');
                }

                // Check document referrer
                if (document.referrer) {
                    const referrer = new URL(document.referrer);
                    if (referrer.hostname === 'accounts.google.com' || referrer.hostname === 'appleid.apple.com') {
                        html += addCheckItem(`‚úì Referrer is OAuth provider: ${referrer.hostname}`, 'success');
                        recordResult(true);
                    } else {
                        html += addCheckItem(`Referrer: ${document.referrer}`, 'info');
                    }
                } else {
                    html += addCheckItem('No referrer (normal for direct access)', 'info');
                }

            } catch (error) {
                html += addCheckItem(`Browser history analysis failed: ${error.message}`, 'error');
                recordResult(false);
            }

            addResult('15. Browser History Analysis', html, passed ? 'success' : 'warning');
        }

        async function testTokenValidation() {
            let html = '';
            let passed = true;

            try {
                html += addCheckItem('üîç Validating tokens in storage...', 'info');

                const client = window.getOrCreateSupabaseClient ? window.getOrCreateSupabaseClient() : 
                               window.supabase.createClient(window.config.supabaseUrl, window.config.supabaseKey);

                if (!client) {
                    html += addCheckItem('Cannot create Supabase client', 'error');
                    recordResult(false);
                    addResult('16. Token Validation', html, 'error');
                    return;
                }

                // Check current session
                const { data: { session }, error } = await client.auth.getSession();

                if (session) {
                    html += addCheckItem('‚úì Active session found', 'success');
                    recordResult(true);

                    // Validate token structure
                    if (session.access_token) {
                        try {
                            const tokenParts = session.access_token.split('.');
                            if (tokenParts.length === 3) {
                                html += addCheckItem('‚úì Access token structure is valid (JWT)', 'success');
                                recordResult(true);

                                // Decode and validate token
                                const payload = JSON.parse(atob(tokenParts[1]));
                                const now = Math.floor(Date.now() / 1000);
                                
                                if (payload.exp && payload.exp > now) {
                                    const minutesUntilExpiry = Math.round((payload.exp - now) / 60);
                                    html += addCheckItem(`Token expires in ${minutesUntilExpiry} minutes`, 'info');
                                } else if (payload.exp) {
                                    html += addCheckItem('‚ùå Token is expired', 'error');
                                    passed = false;
                                    recordResult(false);
                                }

                                if (payload.aud) {
                                    html += addCheckItem(`Token audience: ${payload.aud}`, 'info');
                                }

                                if (payload.iss) {
                                    html += addCheckItem(`Token issuer: ${payload.iss}`, 'info');
                                }
                            } else {
                                html += addCheckItem('‚ö† Token structure is invalid (not a JWT)', 'warning');
                                recordResult(true, true);
                            }
                        } catch (e) {
                            html += addCheckItem(`‚ö† Could not parse token: ${e.message}`, 'warning');
                            recordResult(true, true);
                        }
                    }

                    // Check refresh token
                    if (session.refresh_token) {
                        html += addCheckItem('‚úì Refresh token present', 'success');
                    } else {
                        html += addCheckItem('‚ö† No refresh token found', 'warning');
                        recordResult(true, true);
                    }
                } else {
                    html += addCheckItem('No active session to validate', 'info');
                    recordResult(true);
                }

            } catch (error) {
                html += addCheckItem(`Token validation failed: ${error.message}`, 'error');
                recordResult(false);
            }

            addResult('16. Token Validation', html, passed ? 'success' : 'warning');
        }

        async function testOAuthFlow() {
            clearResults();
            addResult('Testing OAuth Flow', '<div class="check-item info">This will open the OAuth flow. Complete it to see if it works.</div>', 'section');
            
            try {
                const client = window.getOrCreateSupabaseClient ? window.getOrCreateSupabaseClient() : 
                               window.supabase.createClient(window.config.supabaseUrl, window.config.supabaseKey);

                // Store redirect time
                localStorage.setItem('authRedirectTime', Date.now().toString());

                const { data, error } = await client.auth.signInWithOAuth({
                    provider: 'google',
                    options: {
                        redirectTo: WEBSITE_CALLBACK_URL
                    }
                });

                if (error) {
                    clearResults();
                    addResult('OAuth Flow Test', `<div class="check-item error">Error: ${error.message}</div>`, 'error');
                } else if (data?.url) {
                    // Will redirect to OAuth provider
                    window.location.href = data.url;
                }
            } catch (error) {
                clearResults();
                addResult('OAuth Flow Test', `<div class="check-item error">Exception: ${error.message}</div>`, 'error');
            }
        }

        async function testStorage() {
            clearResults();
            await testStorageAnalysis();
        }

        async function testURLHash() {
            clearResults();
            await testURLHashAnalysis();
        }

        function showDetailedInstructions() {
            let html = '<div class="instructions">';
            html += '<h3>üîß Root Cause Analysis & Next Steps</h3>';
            
            const passRate = testResults.total > 0 ? Math.round((testResults.passed / testResults.total) * 100) : 0;
            
            // Check for specific error pattern from diagnostic report
            try {
                const lastError = JSON.parse(localStorage.getItem('oauth_last_error') || 'null');
                if (lastError && lastError.message && lastError.message.includes('No authentication data')) {
                    html += '<div style="background: #fff5f5; padding: 20px; border-radius: 8px; border: 3px solid #dc3545; margin-bottom: 20px;">';
                    html += '<h3 style="color: #dc3545; margin-top: 0;">üö® CRITICAL ISSUE IDENTIFIED</h3>';
                    html += '<p><strong>Error:</strong> "No authentication data in URL. The OAuth redirect may have failed."</p>';
                    html += '<p><strong>What this means:</strong></p>';
                    html += '<ul>';
                    html += '<li>‚úÖ OAuth URL generation works (tests passed)</li>';
                    html += '<li>‚úÖ User was redirected to Google/Apple OAuth provider</li>';
                    html += '<li>‚úÖ User authorized the app</li>';
                    html += '<li>‚ùå <strong>OAuth provider redirected back BUT Supabase failed to exchange the authorization code for tokens</strong></li>';
                    html += '<li>‚ùå The callback page was reached but without tokens in the URL hash</li>';
                    html += '</ul>';
                    html += '<p><strong>üîç Root Cause:</strong> OAuth credentials in Supabase don\'t match what\'s configured in Google/Apple consoles.</p>';
                    html += '<p><strong>üìã IMMEDIATE ACTION REQUIRED:</strong></p>';
                    html += '<ol style="font-weight: bold;">';
                    html += '<li><strong>Google OAuth:</strong><ul style="font-weight: normal;"><li>Go to <a href="https://console.cloud.google.com/" target="_blank">Google Cloud Console</a> ‚Üí APIs & Services ‚Üí Credentials</li><li>Copy the Client ID and Client Secret from your Web Application OAuth client</li><li>Go to <a href="https://supabase.com/dashboard" target="_blank">Supabase Dashboard</a> ‚Üí Authentication ‚Üí Providers ‚Üí Google</li><li>Paste Client ID and Secret EXACTLY (no spaces, no typos)</li><li>Ensure Google provider is <strong>Enabled</strong></li><li>Click <strong>Save</strong></li></ul></li>';
                    html += '<li><strong>Apple OAuth:</strong><ul style="font-weight: normal;"><li>Go to <a href="https://developer.apple.com/account/" target="_blank">Apple Developer Portal</a> ‚Üí Keys</li><li>Find your Sign in with Apple key (or create new one)</li><li>Download the .p8 file and copy its <strong>entire contents</strong></li><li>Note the Key ID and Team ID</li><li>Go to Supabase Dashboard ‚Üí Authentication ‚Üí Providers ‚Üí Apple</li><li>Paste Services ID (Client ID), Secret Key (entire .p8 file contents), Key ID, and Team ID EXACTLY</li><li>Ensure Apple provider is <strong>Enabled</strong></li><li>Click <strong>Save</strong></li></ul></li>';
                    html += '<li><strong>Redirect URIs:</strong> Verify in provider consoles that <code>' + SUPABASE_CALLBACK_URL + '</code> is configured</li>';
                    html += '<li><strong>Wait 5-10 minutes</strong> for changes to propagate</li>';
                    html += '<li><strong>Clear browser storage</strong> and try again</li>';
                    html += '</ol>';
                    html += '</div>';
                }
            } catch (e) {
                // Ignore parsing errors
            }
            
            if (testResults.failed > 0) {
                html += '<p><strong>‚ùå Critical Issues Detected!</strong></p>';
                html += `<p>Failed tests: ${testResults.failed} / ${testResults.total} (${100 - passRate}% failure rate)</p>`;
                html += '<ol>';
                html += '<li><strong>OAuth Credentials Mismatch (Most Likely):</strong>';
                html += '<ul>';
                html += '<li>Since nothing changed in your code, OAuth credentials likely expired or were rotated</li>';
                html += '<li>Check Google Cloud Console ‚Üí APIs & Services ‚Üí Credentials</li>';
                html += '<li>Check Apple Developer Portal ‚Üí Keys (Secret Keys expire after 6 months)</li>';
                html += '<li>Compare values EXACTLY with Supabase Dashboard ‚Üí Authentication ‚Üí Providers</li>';
                html += '</ul></li>';
                html += '<li><strong>Redirect URI Configuration:</strong>';
                html += '<ul>';
                html += '<li>Google: Must include <code>' + SUPABASE_CALLBACK_URL + '</code> in Authorized redirect URIs</li>';
                html += '<li>Apple: Must include <code>' + SUPABASE_CALLBACK_URL + '</code> in Return URLs</li>';
                html += '<li>NOT your website URL - must be Supabase callback URL</li>';
                html += '</ul></li>';
                html += '<li><strong>Provider Status:</strong> Ensure both Google and Apple providers are Enabled in Supabase</li>';
                html += '</ol>';
            } else if (testResults.warnings > 0) {
                html += '<p><strong>‚ö† Warnings Detected</strong></p>';
                html += `<p>Warnings: ${testResults.warnings} / ${testResults.total} tests</p>`;
                html += '<p>Review the detailed test results above. Common warning causes:</p>';
                html += '<ul>';
                html += '<li>Stale tokens in storage (clear storage and try again)</li>';
                html += '<li>Recent redirects (may indicate redirect loops)</li>';
                html += '<li>Network latency (may affect OAuth flow timing)</li>';
                html += '</ul>';
            } else {
                html += '<p><strong>‚úì All Tests Passed!</strong></p>';
                html += `<p>Pass rate: ${passRate}% (${testResults.passed} / ${testResults.total} tests passed)</p>`;
                html += '<p>If authentication still fails despite all tests passing:</p>';
                html += '<ol>';
                html += '<li>Clear browser storage completely</li>';
                html += '<li>Test in incognito/private window</li>';
                html += '<li>Try the actual OAuth flow (click "Test OAuth Flow" button)</li>';
                html += '<li>Check Supabase Auth Logs: Dashboard ‚Üí Logs ‚Üí Auth Logs</li>';
                html += '</ol>';
            }
            
            html += '<hr style="margin: 20px 0; border: none; border-top: 1px solid #ddd;">';
            
            html += '<h4>üîß Step-by-Step Fix Instructions</h4>';
            html += '<ol>';
            html += '<li><strong>Verify OAuth URLs Generate Successfully:</strong> If Test #5 passes, OAuth URL generation works</li>';
            html += '<li><strong>Check for Error Patterns:</strong> Review Test #8 for error patterns in storage/URL</li>';
            html += '<li><strong>Validate Credentials:</strong> Compare Test #6 output with your provider console values</li>';
            html += '<li><strong>Check Callback Exchange:</strong> Review Test #7 - if on callback page, it will simulate the exchange</li>';
            html += '<li><strong>Update Credentials in Supabase:</strong> Dashboard ‚Üí Authentication ‚Üí Providers ‚Üí Update Google/Apple</li>';
            html += '<li><strong>Wait 5-10 Minutes:</strong> OAuth changes can take time to propagate</li>';
            html += '<li><strong>Clear Storage & Retry:</strong> Clear all data and test again</li>';
            html += '</ol>';
            
            html += '<hr style="margin: 20px 0; border: none; border-top: 1px solid #ddd;">';
            
            html += '<h4>üéØ Next Steps to Diagnose</h4>';
            html += '<p><strong>Since all diagnostic tests pass but authentication still fails:</strong></p>';
            html += '<ol>';
            html += '<li><strong>Run the actual OAuth flow:</strong> Click "Test OAuth Flow" button above to trigger real authentication</li>';
            html += '<li><strong>Complete the OAuth flow:</strong> Authorize with Google/Apple when prompted</li>';
            html += '<li><strong>If it fails:</strong> You\'ll be redirected back to auth.html with an error</li>';
            html += '<li><strong>Return to diagnostic:</strong> Come back to this page and run "Run Full Diagnostic" again</li>';
            html += '<li><strong>Check Test #8:</strong> It will now show the actual error from the callback exchange</li>';
            html += '</ol>';
            html += '<p><strong>üí° The diagnostic tool now captures errors from the callback page automatically!</strong></p>';
            
            html += '<hr style="margin: 20px 0; border: none; border-top: 1px solid #ddd;">';
            
            html += '<h4>üí° Quick Reference</h4>';
            html += '<ul>';
            html += '<li><strong>Supabase Callback URL:</strong> <code>' + SUPABASE_CALLBACK_URL + '</code></li>';
            html += '<li><strong>Website Callback URL:</strong> <code>' + WEBSITE_CALLBACK_URL + '</code></li>';
            html += '<li><strong>Google Cloud Console:</strong> <a href="https://console.cloud.google.com/" target="_blank">console.cloud.google.com</a></li>';
            html += '<li><strong>Apple Developer Portal:</strong> <a href="https://developer.apple.com/account/" target="_blank">developer.apple.com/account</a></li>';
            html += '<li><strong>Supabase Dashboard:</strong> <a href="https://supabase.com/dashboard" target="_blank">supabase.com/dashboard</a></li>';
            html += '</ul>';
            
            html += '</div>';
            
            addResult('üìù Instructions', html, testResults.failed > 0 ? 'error' : testResults.warnings > 0 ? 'warning' : 'success');
        }

        async function testConsoleErrorAnalysis() {
            let html = '';
            let passed = true;
            const errors = [...errorMonitor.consoleErrors];
            
            // Also load stored errors
            try {
                const storedErrors = JSON.parse(localStorage.getItem('oauth_console_errors') || '[]');
                storedErrors.forEach(err => {
                    if (!errors.find(e => e.timestamp === err.timestamp)) {
                        errors.push(err);
                    }
                });
            } catch (e) {
                // Ignore
            }
            
            if (errors.length === 0) {
                html += addCheckItem('‚úì No console errors captured', 'success');
                recordResult(true);
                addResult('17. Console Error Analysis', html, 'success');
                return;
            }
            
            html += addCheckItem(`Found ${errors.length} console error(s)`, errors.length > 5 ? 'warning' : 'info');
            recordResult(true, errors.length > 5);
            
            // Filter auth-related errors
            const authErrors = errors.filter(err => {
                const msg = (err.message || '').toLowerCase();
                return msg.includes('auth') || msg.includes('oauth') || msg.includes('supabase') || 
                       msg.includes('token') || msg.includes('session') || msg.includes('callback');
            });
            
            if (authErrors.length > 0) {
                html += addCheckItem(`‚ö† ${authErrors.length} auth-related error(s) found`, 'warning');
                recordResult(true, true);
                passed = false;
                
                let errorDetails = '';
                authErrors.slice(-10).forEach((err, idx) => {
                    const time = new Date(err.timestamp).toLocaleString();
                    errorDetails += `<div style="margin: 5px 0; padding: 8px; background: #fff; border-radius: 4px;">`;
                    errorDetails += `<strong>${idx + 1}. [${time}] ${err.type || 'error'}:</strong><br>`;
                    errorDetails += `<code>${err.message || 'No message'}</code>`;
                    if (err.stack) {
                        errorDetails += `<details style="margin-top: 5px;"><summary>Stack trace</summary><pre style="font-size: 0.8em; overflow-x: auto; margin-top: 5px;">${err.stack}</pre></details>`;
                    }
                    if (err.filename) {
                        errorDetails += `<br><small>File: ${err.filename}:${err.lineno}:${err.colno}</small>`;
                    }
                    errorDetails += `</div>`;
                });
                
                html += addCheckItem('Auth-related console errors', 'error', errorDetails);
                
                // Analyze patterns
                const allErrorMessages = authErrors.map(e => e.message?.toLowerCase() || '').join(' ');
                if (allErrorMessages.includes('exchange') || allErrorMessages.includes('code')) {
                    html += addCheckItem('üîç Pattern: "exchange" errors detected in console - OAuth credentials issue', 'error');
                }
                if (allErrorMessages.includes('already declared') || allErrorMessages.includes('identifier')) {
                    html += addCheckItem('üîç Pattern: Variable redeclaration - JavaScript scope issue', 'error');
                }
                if (allErrorMessages.includes('404') || allErrorMessages.includes('not found')) {
                    html += addCheckItem('üîç Pattern: 404 errors - missing config files or endpoints', 'error');
                }
            } else {
                html += addCheckItem('‚úì No auth-related console errors', 'success');
            }
            
            addResult('17. Console Error Analysis', html, passed ? 'warning' : 'error');
        }

        async function testNetworkErrorAnalysis() {
            let html = '';
            let passed = true;
            const networkErrors = [...errorMonitor.networkErrors];
            
            // Also load stored network errors
            try {
                const storedNetwork = JSON.parse(localStorage.getItem('oauth_network_errors') || '[]');
                storedNetwork.forEach(err => {
                    if (!networkErrors.find(e => e.timestamp === err.timestamp)) {
                        networkErrors.push(err);
                    }
                });
            } catch (e) {
                // Ignore
            }
            
            if (networkErrors.length === 0) {
                html += addCheckItem('‚úì No network errors captured', 'success');
                recordResult(true);
                addResult('18. Network Error Analysis', html, 'success');
                return;
            }
            
            html += addCheckItem(`Found ${networkErrors.length} network error(s)`, networkErrors.length > 5 ? 'warning' : 'info');
            recordResult(true, networkErrors.length > 5);
            
            // Filter auth-related network errors
            const authNetworkErrors = networkErrors.filter(err => {
                const url = (err.url || '').toLowerCase();
                return url.includes('auth') || url.includes('oauth') || url.includes('supabase') || 
                       url.includes('callback') || url.includes('token');
            });
            
            if (authNetworkErrors.length > 0) {
                html += addCheckItem(`‚ö† ${authNetworkErrors.length} auth-related network error(s)`, 'warning');
                recordResult(true, true);
                passed = false;
                
                let errorDetails = '';
                authNetworkErrors.slice(-10).forEach((err, idx) => {
                    const time = new Date(err.timestamp).toLocaleString();
                    errorDetails += `<div style="margin: 5px 0; padding: 8px; background: #fff; border-radius: 4px;">`;
                    errorDetails += `<strong>${idx + 1}. [${time}] ${err.method || 'GET'} ${err.status || 'ERROR'}:</strong><br>`;
                    errorDetails += `<code>${err.url}</code>`;
                    if (err.status) {
                        errorDetails += `<br><small>Status: ${err.status} ${err.statusText || ''}</small>`;
                    }
                    if (err.latency) {
                        errorDetails += `<br><small>Latency: ${err.latency}ms</small>`;
                    }
                    if (err.error) {
                        errorDetails += `<br><small>Error: ${err.error}</small>`;
                    }
                    errorDetails += `</div>`;
                });
                
                html += addCheckItem('Auth-related network errors', 'error', errorDetails);
                
                // Analyze status codes
                const statusCodes = authNetworkErrors.map(e => e.status).filter(s => s);
                if (statusCodes.includes(401) || statusCodes.includes(403)) {
                    html += addCheckItem('üîç Pattern: 401/403 errors - authentication/authorization issues', 'error');
                }
                if (statusCodes.includes(404)) {
                    html += addCheckItem('üîç Pattern: 404 errors - endpoints not found or misconfigured', 'error');
                }
                if (statusCodes.includes(500) || statusCodes.includes(502) || statusCodes.includes(503)) {
                    html += addCheckItem('üîç Pattern: 5xx errors - server-side issues, possibly OAuth provider problems', 'error');
                }
            } else {
                html += addCheckItem('‚úì No auth-related network errors', 'success');
            }
            
            addResult('18. Network Error Analysis', html, passed ? 'warning' : 'error');
        }

        async function testOAuthFlowTracking() {
            let html = '';
            let passed = true;
            
            // Check for OAuth flow steps in localStorage
            const flowSteps = [];
            
            try {
                // Check for callback tracking
                const lastCallback = localStorage.getItem('oauth_last_callback');
                if (lastCallback) {
                    const callbackInfo = JSON.parse(lastCallback);
                    flowSteps.push({
                        step: 'Callback Page Reached',
                        timestamp: callbackInfo.timestamp,
                        success: callbackInfo.hasHash,
                        details: callbackInfo
                    });
                }
                
                // Check for redirect time
                const redirectTime = localStorage.getItem('authRedirectTime');
                if (redirectTime) {
                    flowSteps.push({
                        step: 'Redirect Initiated',
                        timestamp: parseInt(redirectTime),
                        success: true,
                        details: { redirectTime: parseInt(redirectTime) }
                    });
                }
                
                // Check for error during flow
                const lastError = localStorage.getItem('oauth_last_error');
                if (lastError) {
                    const errorInfo = JSON.parse(lastError);
                    flowSteps.push({
                        step: 'Error During Flow',
                        timestamp: errorInfo.timestamp,
                        success: false,
                        details: errorInfo
                    });
                }
                
                if (flowSteps.length === 0) {
                    html += addCheckItem('No OAuth flow steps tracked (normal if not attempted)', 'info');
                    recordResult(true);
                    addResult('19. OAuth Flow Tracking', html, 'success');
                    return;
                }
                
                // Sort by timestamp
                flowSteps.sort((a, b) => a.timestamp - b.timestamp);
                
                html += addCheckItem(`Tracked ${flowSteps.length} OAuth flow step(s)`, 'info');
                recordResult(true);
                
                let flowDetails = '<div style="margin-top: 10px;"><strong>Flow Timeline:</strong><ol>';
                flowSteps.forEach((step, idx) => {
                    const time = new Date(step.timestamp).toLocaleString();
                    const status = step.success ? '‚úì' : '‚úó';
                    flowDetails += `<li style="margin: 5px 0;"><strong>${status} ${step.step}</strong> - ${time}</li>`;
                    
                    if (!step.success && step.details) {
                        if (step.details.message) {
                            flowDetails += `<div style="margin-left: 20px; color: #dc3545;"><code>${step.details.message}</code></div>`;
                        }
                    }
                });
                flowDetails += '</ol></div>';
                
                // Check for incomplete flows
                const hasCallback = flowSteps.some(s => s.step.includes('Callback'));
                const hasError = flowSteps.some(s => s.step.includes('Error'));
                
                if (hasCallback && !hasError) {
                    html += addCheckItem('‚úì OAuth flow appears to have completed successfully', 'success');
                } else if (hasError) {
                    html += addCheckItem('‚ö† OAuth flow encountered an error', 'warning');
                    recordResult(true, true);
                    passed = false;
                } else if (flowSteps.length === 1 && flowSteps[0].step.includes('Redirect')) {
                    html += addCheckItem('‚ö† OAuth flow started but no callback tracked - may have been interrupted', 'warning');
                    recordResult(true, true);
                }
                
                html += addCheckItem('OAuth flow timeline', 'info', flowDetails);
                
            } catch (error) {
                html += addCheckItem(`Flow tracking analysis failed: ${error.message}`, 'error');
                recordResult(false);
            }
            
            addResult('19. OAuth Flow Tracking', html, passed ? 'success' : 'warning');
        }

        async function exportDiagnosticReport() {
            const btn = document.getElementById('exportBtn');
            btn.disabled = true;
            btn.innerHTML = '‚è≥ Generating...';
            
            try {
                const report = {
                    timestamp: new Date().toISOString(),
                    url: window.location.href,
                    userAgent: navigator.userAgent,
                    testResults: testResults,
                    configuration: {
                        supabaseUrl: window.config?.supabaseUrl,
                        hasSupabaseKey: !!window.config?.supabaseKey,
                        callbackUrl: WEBSITE_CALLBACK_URL,
                        supabaseCallbackUrl: SUPABASE_CALLBACK_URL
                    },
                    storedErrors: {
                        consoleErrors: JSON.parse(localStorage.getItem('oauth_console_errors') || '[]'),
                        networkErrors: JSON.parse(localStorage.getItem('oauth_network_errors') || '[]'),
                        lastError: JSON.parse(localStorage.getItem('oauth_last_error') || 'null'),
                        diagnosticErrors: JSON.parse(localStorage.getItem('oauth_diagnostic_errors') || '[]'),
                        callbackParams: JSON.parse(localStorage.getItem('oauth_callback_params') || 'null'),
                        lastCallback: JSON.parse(localStorage.getItem('oauth_last_callback') || 'null')
                    },
                    currentUrl: {
                        href: window.location.href,
                        hash: window.location.hash,
                        search: window.location.search,
                        pathname: window.location.pathname
                    },
                    storage: {
                        localStorageKeys: Object.keys(localStorage).filter(k => 
                            k.includes('auth') || k.includes('supabase') || k.includes('oauth') || k.includes('sb-')
                        ),
                        sessionStorageKeys: Object.keys(sessionStorage)
                    },
                    monitoring: {
                        active: errorMonitor.active,
                        monitoringDuration: errorMonitor.monitoringStartTime ? 
                            Date.now() - errorMonitor.monitoringStartTime : 0,
                        consoleErrorsCaptured: errorMonitor.consoleErrors.length,
                        networkErrorsCaptured: errorMonitor.networkErrors.length
                    }
                };
                
                // Create downloadable file
                const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `oauth-diagnostic-report-${Date.now()}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                addResult('Report Exported', '<div class="check-item success">‚úì Diagnostic report exported successfully. Share this file for troubleshooting.</div>', 'success');
                
                // Also show a text version in the results
                const textReport = `=== OAuth Diagnostic Report ===
Generated: ${report.timestamp}
URL: ${report.url}

Test Results:
- Total: ${report.testResults.total}
- Passed: ${report.testResults.passed}
- Failed: ${report.testResults.failed}
- Warnings: ${report.testResults.warnings}

Stored Errors:
- Console Errors: ${report.storedErrors.consoleErrors.length}
- Network Errors: ${report.storedErrors.networkErrors.length}
- Diagnostic Errors: ${report.storedErrors.diagnosticErrors.length}

${report.storedErrors.lastError ? `Last Error: ${report.storedErrors.lastError.message}` : 'No last error'}

Configuration:
- Supabase URL: ${report.configuration.supabaseUrl}
- Has API Key: ${report.configuration.hasSupabaseKey}
- Callback URL: ${report.configuration.callbackUrl}

=== End Report ===
`;
                
                const textBlob = new Blob([textReport], { type: 'text/plain' });
                const textUrl = URL.createObjectURL(textBlob);
                const textA = document.createElement('a');
                textA.href = textUrl;
                textA.download = `oauth-diagnostic-report-${Date.now()}.txt`;
                document.body.appendChild(textA);
                textA.click();
                document.body.removeChild(textA);
                URL.revokeObjectURL(textUrl);
                
            } catch (error) {
                addResult('Export Failed', `<div class="check-item error">Export failed: ${error.message}</div>`, 'error');
            } finally {
                btn.disabled = false;
                btn.innerHTML = 'üìã Export Report';
            }
        }

        async function clearAllData() {
            if (!confirm('This will sign you out and clear all local storage. Continue?')) {
                return;
            }

            try {
                const client = window.getOrCreateSupabaseClient ? window.getOrCreateSupabaseClient() : window.supabaseClient;
                if (client) {
                    await client.auth.signOut();
                }
                
                // Clear monitoring data
                errorMonitor.consoleErrors = [];
                errorMonitor.networkErrors = [];
                errorMonitor.oauthFlowSteps = [];
                
                localStorage.clear();
                sessionStorage.clear();
                
                alert('All data cleared! Refreshing page...');
                location.reload();
            } catch (error) {
                alert('Error: ' + error.message);
            }
        }

        // Auto-run on load
        document.addEventListener('configLoaded', () => {
            setTimeout(() => runFullDiagnostic(), 500);
        });

        if (window.config) {
            setTimeout(() => runFullDiagnostic(), 500);
        }
    </script>
</body>
</html>
