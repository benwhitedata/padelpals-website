<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Padel Pals - Dashboard</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="icon" href="Icon.png" type="image/png">
    <!-- Font Awesome for icons -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <!-- Load Supabase JS and config loader first -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="config-loader.js"></script>
    <style>
        :root {
            --gold: #d4af37;
            --dark-blue: #1a2238;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #333;
            line-height: 1.6;
            background-color: #ffffff;
        }

        .navbar {
            background-color: var(--dark-blue);
        }

        .navbar-brand, .nav-link {
            color: white;
        }

        .nav-link:hover {
            color: var(--gold);
        }

        .nav-link.active {
            color: var(--gold) !important;
        }

        .dashboard-container {
            max-width: 1200px;
            margin: 40px auto;
            padding: 20px;
        }

        .stats-card {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .stats-card h3 {
            color: var(--dark-blue);
            margin-bottom: 15px;
        }

        .footer {
            background-color: var(--dark-blue);
            color: white;
            padding: 40px 0;
            text-align: center;
            margin-top: 40px;
        }

        .footer a {
            color: var(--gold);
            text-decoration: none;
        }

        .footer a:hover {
            text-decoration: underline;
        }

        .loading {
            text-align: center;
            padding: 40px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 50vh;
        }

        .spinner {
            border: 5px solid rgba(26, 34, 56, 0.1);
            border-top: 5px solid var(--dark-blue);
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }

            100% { transform: rotate(360deg); }

        }

        .message {
            margin-top: 15px;
            padding: 10px;
            border-radius: 5px;
        }

        .error-message {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .info-message {
            background-color: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .navbar-toggler-icon {
            background-color: unset;
        }

        
        /* Box League Styles */
        .box-league-container {
            margin-bottom: 40px;
        }

        .league-table {
            width: 100%;
            overflow-x: auto;
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .league-table table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
        }

        .league-table th, .league-table td {
            padding: 8px 12px;
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .league-table th {
            background-color: rgba(26, 34, 56, 0.7);
            color: white;
            position: sticky;
            top: 0;
        }

        .league-table th:first-child {
            text-align: left;
            min-width: 150px;
        }

        .league-table td:first-child {
            text-align: left;
        }

        .league-table .team-name {
            font-weight: 500;
        }

        .match-result {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            cursor: pointer;
        }

        .match-win {
            background-color: rgba(40, 167, 69, 0.2);
            color: #28a745;
        }

        .match-loss {
            background-color: rgba(220, 53, 69, 0.15);
            color: #dc3545;
        }

        .match-unplayed {
            background-color: rgba(108, 117, 125, 0.1);
            color: #6c757d;
        }

        .match-scheduled {
            background-color: rgba(0, 123, 255, 0.15);
            color: #007bff;
        }

        .match-walkover-win {
            background-color: rgba(0, 123, 255, 0.2);
            color: #007bff;
        }

        .match-walkover-loss {
            background-color: rgba(255, 193, 7, 0.2);
            color: #ffc107;
        }

        .matches-container {
            max-height: 360px;
            overflow-y: auto;
        }

        .match-card {
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 10px;
        }

        .match-card .match-date {
            color: #6c757d;
            font-size: 0.9rem;
        }

        .match-card .team-names {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 8px 0;
        }

        .match-card .team {
            max-width: 45%;
            text-align: center;
        }

        .match-card .score {
            font-weight: bold;
            min-width: 60px;
            text-align: center;
        }

        .match-status {
            display: inline-block;
            font-size: 0.8rem;
            padding: 2px 8px;
            border-radius: 12px;
            margin-left: 8px;
        }

        .status-scheduled {
            background-color: rgba(0, 123, 255, 0.2);
            color: #007bff;
        }

        .status-completed {
            background-color: rgba(40, 167, 69, 0.2);
            color: #28a745;
        }

        .status-walkover {
            background-color: rgba(255, 193, 7, 0.2);
            color: #ffc107;
        }

        .placeholder-text {
            color: #6c757d;
            font-style: italic;
        }

        #boxSelector select {
            background-color: #343a40;
            color: #f8f9fa;
            border: 1px solid #495057;
            padding: 8px 12px;
            border-radius: 5px;
            width: 100%;
            font-weight: 500;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        #leagueSelector select {
            background-color: #343a40;
            color: #f8f9fa;
            border: 1px solid #495057;
            padding: 8px 12px;
            border-radius: 5px;
            width: 100%;
            font-weight: 500;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        .form-select {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3e%3cpath fill='none' stroke='%23f8f9fa' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M2 5l6 6 6-6'/%3e%3c/svg%3e") !important;
            background-repeat: no-repeat;
            background-position: right 0.75rem center;
            background-size: 16px 12px;
        }

        .form-select:focus {
            border-color: var(--gold);
            box-shadow: 0 0 0 0.25rem rgba(212, 175, 55, 0.25);
        }

        .form-label {
            color: #333333;
            font-weight: 600;
            display: block;
            margin-bottom: 0.5rem;
        }

        .status-filters {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .status-filter-btn {
            padding: 8px 16px;
            border-radius: 20px;
            border: 1px solid #495057;
            background-color: #343a40;
            color: #f8f9fa;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.9rem;
            font-weight: 500;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        /* Status-specific styling */
        .status-filter-btn[data-status="active"] {
            background-color: #1e3a8a;
            border-color: #1e4d8a;
            color: #ffffff;
        }

        .status-filter-btn[data-status="upcoming"] {
            background-color: #0e7490;
            border-color: #0e6890;
            color: #ffffff;
        }

        .status-filter-btn[data-status="completed"] {
            background-color: #4b5563;
            border-color: #6b7280;
            color: #ffffff;
        }

        .status-filter-btn[data-status="cancelled"] {
            background-color: #991b1b;
            border-color: #7f1d1d;
            color: #ffffff;
        }

        .status-filter-btn[data-status="all"] {
            background-color: #525252;
            border-color: #6b7280;
            color: #ffffff;
        }

        .status-filter-btn.active {
            background-color: var(--dark-blue);
            border-color: var(--dark-blue);
            color: var(--gold);
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            transform: translateY(-1px);
        }

        .status-filter-btn:hover:not(.active) {
            filter: brightness(1.2);
            transform: translateY(-1px);
        }

        .form-select option {
            background-color: #343a40;
            color: #f8f9fa;
            padding: 8px;
        }

        /* Custom selection area styling */
        .selector-area {
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid #dee2e6;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        /* Fix for tab navigation */
        .nav-tabs {
            border-bottom: 1px solid #dee2e6;
        }

        .nav-tabs .nav-item {
            margin-bottom: -1px;
            display: inline-block;
        }

        .nav-tabs .nav-link {
            color: #495057;
            border: 1px solid transparent;
            border-top-left-radius: 0.25rem;
            border-top-right-radius: 0.25rem;
            padding: 0.5rem 1rem;
            display: inline-block;
            text-decoration: none;
            background-color: transparent;
        }

        .nav-tabs .nav-link:hover {
            border-color: #e9ecef #e9ecef #dee2e6;
            color: var(--gold);
            background-color: rgba(26, 34, 56, 0.05);
        }

        .nav-tabs .nav-link.active {
            color: var(--gold);
            background-color: var(--dark-blue);
            border-color: #dee2e6 #dee2e6 #fff;
        }

        /* Ensure tabs are all visible */
        #dashboardTabs {
            display: flex;
            flex-wrap: wrap;
        }

        #dashboardTabs .nav-item {
            flex: 0 0 auto;
            margin-right: 2px;
        }

        /* Match History Styles */
        .match-history-card {
            background-color: rgba(26, 34, 56, 0.8);
            border-radius: 12px;
            border: 1px solid var(--gold);
            padding: 15px;
            margin-bottom: 16px;
            color: white;
        }

        .match-history-card .match-date {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .match-history-card .match-teams {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .match-history-card .team-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .match-history-card .team-players {
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .match-history-card .team-score {
            display: flex;
            gap: 6px;
            min-width: 100px;
            justify-content: flex-end;
        }

        .match-history-card .set-score {
            display: inline-block;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.2);
            text-align: center;
            line-height: 24px;
            color: white;
        }

        .match-history-card .winning-team {
            font-weight: bold;
            color: var(--gold);
        }

        .match-history-card .set-divider {
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            margin: 10px 0;
        }

        .match-history-card .match-category {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            background-color: rgba(26, 34, 56, 0.9);
            color: white;
        }

        .match-history-card .match-type-private {
            background-color: rgba(108, 117, 125, 0.6);
        }

        .match-history-card .match-type-open {
            background-color: rgba(0, 123, 255, 0.6);
        }

        .match-history-card .match-type-competitive {
            background-color: rgba(40, 167, 69, 0.6);
        }

        .match-history-card .match-type-boxleague {
            background-color: rgba(255, 193, 7, 0.6);
        }

        #matchHistoryContent {
            max-height: 600px;
            overflow-y: auto;
        }

        .match-filter-section {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .match-filter-pill {
            padding: 5px 12px;
            border-radius: 16px;
            background-color: rgba(26, 34, 56, 0.7);
            color: white;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
        }

        .match-filter-pill.active {
            background-color: var(--gold);
            color: var(--dark-blue);
        }

        .match-filter-pill i {
            font-size: 0.75rem;
        }

        /* Match filters and inputs */
        #matchHistoryFilter, #matchDateRangeFilter {
            background-color: var(--dark-blue);
            color: white;
            border-color: rgba(255, 255, 255, 0.2);
        }

        #matchSearchInput {
            background-color: rgba(255, 255, 255, 0.1);
            color: white;
            border-color: rgba(255, 255, 255, 0.2);
        }
        
        #matchSearchInput::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        /* Stats card modifications */
        .stats-card {
            background-color: #ffffff;
            color: #333;
        }
        
        /* Only make titles in the Stats tab white */
        #stats .stats-card {
            background-color: var(--dark-blue);
            color: white;
        }
        
        #stats .stats-card h3 {
            color: white;
        }
        
        /* Keep text-muted as its original color in Profile tab */
        .text-muted {
            color: #6c757d !important;
        }
        
        /* Override text-muted only in Stats tab */
        #stats .text-muted {
            color: rgba(255, 255, 255, 0.6) !important;
        }

        /* Match details modal improvement */
        .match-detail-result {
            background-color: rgba(26, 34, 56, 0.9) !important;
        }
        
        .table-dark {
            background-color: rgba(26, 34, 56, 0.6) !important;
        }
        
        .modal-content.bg-dark {
            background-color: var(--dark-blue) !important;
            color: white;
        }
        
        #matchesEmpty {
            color: white;
        }
        
        #matchesEmpty .text-muted {
            color: rgba(255, 255, 255, 0.7) !important;
        }
        
        /* Recent matches section */
        #recentMatches .d-flex {
            background-color: rgba(26, 34, 56, 0.7) !important;
        }
        
        /* Match stats elements */
        #matchStats .border {
            background-color: rgba(26, 34, 56, 0.7);
        }
        
        @media (max-width: 768px) {
            .match-history-card .team-score {
                min-width: 80px;
            }
        }
        
        /* Input group for search */
        .input-group-text {
            background-color: var(--dark-blue);
            color: rgba(255, 255, 255, 0.8);
            border-color: rgba(255, 255, 255, 0.2);
        }
        
        /* Match Detail Modal Styles */
        .border-gold {
            border: 1px solid var(--gold);
        }
        
        .modal-content.bg-dark {
            background-color: var(--dark-blue) !important;
        }
        
        .modal-header {
            border-bottom-color: rgba(255, 255, 255, 0.1);
        }
        
        .modal-footer {
            border-top-color: rgba(255, 255, 255, 0.1);
        }
        
        .winning-score {
            color: var(--gold);
            font-weight: bold;
        }
        
        .table-dark {
            background-color: transparent;
            color: white;
        }
        
        .table-dark th, .table-dark td {
            border-color: rgba(255, 255, 255, 0.1);
        }

        /* Custom date picker styling */
        .date-picker {
            background-color: var(--dark-blue);
            color: white;
            border-color: rgba(255, 255, 255, 0.2);
        }
        
        .date-picker:focus {
            background-color: var(--dark-blue);
            color: white;
            border-color: var(--gold);
            box-shadow: 0 0 0 0.25rem rgba(212, 175, 55, 0.25);
        }
        
        /* Date-picker calendar icon */
        .date-picker::-webkit-calendar-picker-indicator {
            filter: invert(1);
            opacity: 0.7;
        }
        
        .date-picker::-webkit-calendar-picker-indicator:hover {
            opacity: 1;
        }
    </style>
    <!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-L426ZMNKFK"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}

      gtag('js', new Date());

      gtag('config', 'G-L426ZMNKFK');
    </script>
    <!-- End Google Analytics -->
    
    <!-- Chart.js for Rating Trend -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    
    <!-- Components loader -->
    <script src="js/components.js"></script>
</head>
<body>
    <!-- Navigation container - will be filled by JavaScript -->
    <div id="navbar-container"></div>
    <div class="dashboard-container">
        <div id="loading" class="loading">
            <div class="spinner"></div>
            <h2>Loading your data...</h2>
            <!-- Hidden elements for error handling -->
            <div style="display: none;">
                <button id="goToAuth" class="btn btn-primary mt-3">Go to Sign In</button>
            </div>
        </div>
        
        <div id="dashboardContent" style="display: none;">
            <h1 class="mb-4">Welcome, <span id="userName">User</span>!</h1>
            
            <!-- Tab Navigation -->
            <ul class="nav nav-tabs mb-4" id="dashboardTabs" role="tablist">
                <li class="nav-item" role="presentation">
                    <button class="nav-link active" id="profile-tab" data-bs-toggle="tab" data-bs-target="#profile" type="button" role="tab" aria-controls="profile" aria-selected="true">Profile</button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="boxleague-tab" data-bs-toggle="tab" data-bs-target="#boxleague" type="button" role="tab" aria-controls="boxleague" aria-selected="false">Box League</button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="stats-tab" data-bs-toggle="tab" data-bs-target="#stats" type="button" role="tab" aria-controls="stats" aria-selected="false">Stats</button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="settings-tab" data-bs-toggle="tab" data-bs-target="#settings" type="button" role="tab" aria-controls="settings" aria-selected="false">Settings</button>
                </li>
            </ul>
            
            <!-- Tab Content -->
            <div class="tab-content" id="dashboardTabContent">
                <!-- Profile Tab -->
                <div class="tab-pane fade show active" id="profile" role="tabpanel" aria-labelledby="profile-tab">
                    <div class="row">
                        <div class="col-lg-8 mx-auto">
                            <!-- Player Information -->
                            <div class="stats-card mb-4">
                                <h3>Player Information</h3>
                                <form id="profileForm">
                                    <div class="mb-3">
                                        <label for="playerName" class="form-label">Name</label>
                                        <div class="d-flex">
                                            <input type="text" class="form-control" id="playerName" disabled>
                                            <button type="button" id="editNameBtn" class="btn btn-outline-primary ms-2">Edit</button>
                                        </div>
                                    </div>
                                    
                                    <div class="mb-3">
                                        <label class="form-label">Rating</label>
                                        <div class="d-flex align-items-center">
                                            <span id="playerRating" class="me-2">—</span>
                                            <i class="fas fa-star text-warning"></i>
                                            <button type="button" id="refreshRatingBtn" class="btn btn-sm btn-outline-secondary ms-2">
                                                <i class="fas fa-sync-alt"></i>
                                            </button>
                                        </div>
                                    </div>
                                    
                                    <div class="mb-3">
                                        <label class="form-label">Category</label>
                                        <div>
                                            <span id="playerCategory">—</span>
                                        </div>
                                        <small id="categoryDefinition" class="form-text text-muted"></small>
                                    </div>
                                    
                                    <div class="mb-3">
                                        <label class="form-label">Assessment Date</label>
                                        <div>
                                            <span id="assessmentDate">—</span>
                                        </div>
                                    </div>
                                    
                                    <div class="mb-3">
                                        <label class="form-label">Assessed by</label>
                                        <div>
                                            <span id="assessedBy">—</span>
                                        </div>
                                    </div>
                                </form>
                            </div>
                            
                            <!-- Match Rating -->
                            <div class="stats-card mb-4">
                                <h3>Match Rating</h3>
                                <div class="mb-3">
                                    <label class="form-label">Latest Rating</label>
                                    <div>
                                        <span id="matchRating">—</span>
                                    </div>
                                </div>
                                
                                <div class="mb-3">
                                    <label class="form-label">Confidence</label>
                                    <div>
                                        <span id="ratingConfidence">—</span>
                                    </div>
                                </div>
                                
                                <button type="button" id="viewRatingTrendBtn" class="btn btn-outline-primary">
                                    <i class="fas fa-chart-line me-2"></i>View Rating Trend
                                </button>
                                
                                <!-- Rating Trend Chart (initially hidden) -->
                                <div id="ratingTrendContainer" class="mt-4" style="display: none;">
                                    <!-- Time range selector -->
                                    <div class="mb-3">
                                        <label class="form-label">Time Range</label>
                                        <select id="timeRangeSelector" class="form-select">
                                            <option value="week">Week</option>
                                            <option value="month">Month</option>
                                            <option value="threeMonths">3 Months</option>
                                            <option value="sixMonths">6 Months</option>
                                            <option value="year">Year</option>
                                            <option value="all" selected>All</option>
                                        </select>
                                    </div>
                                    
                                    <!-- Chart container -->
                                    <div class="chart-container" style="position: relative; height: 300px;">
                                        <canvas id="ratingChart"></canvas>
                                    </div>
                                    
                                    <!-- Chart legend -->
                                    <div class="d-flex justify-content-center mt-2">
                                        <div class="d-flex align-items-center me-3">
                                            <div class="rounded-circle me-1" style="width: 10px; height: 10px; background-color: var(--gold);"></div>
                                            <small>Match Ratings</small>
                                        </div>
                                        <div class="d-flex align-items-center">
                                            <div class="rounded-circle me-1" style="width: 10px; height: 10px; background-color: red;"></div>
                                            <small>Coach Ratings</small>
                                        </div>
                                    </div>
                                    
                                    <!-- Rating stats -->
                                    <div class="row mt-3" id="ratingStats">
                                        <div class="col-6 col-sm-3 mb-2">
                                            <div class="card bg-light">
                                                <div class="card-body p-2 text-center">
                                                    <h6 class="mb-1">Highest</h6>
                                                    <span id="highestRating" class="h4">—</span>
                                                </div>
                                            </div>
                                        </div>
                                        <div class="col-6 col-sm-3 mb-2">
                                            <div class="card bg-light">
                                                <div class="card-body p-2 text-center">
                                                    <h6 class="mb-1">Lowest</h6>
                                                    <span id="lowestRating" class="h4">—</span>
                                                </div>
                                            </div>
                                        </div>
                                        <div class="col-6 col-sm-3 mb-2">
                                            <div class="card bg-light">
                                                <div class="card-body p-2 text-center">
                                                    <h6 class="mb-1">Average</h6>
                                                    <span id="averageRating" class="h4">—</span>
                                                </div>
                                            </div>
                                        </div>
                                        <div class="col-6 col-sm-3 mb-2">
                                            <div class="card bg-light">
                                                <div class="card-body p-2 text-center">
                                                    <h6 class="mb-1">Matches</h6>
                                                    <span id="matchesCount" class="h4">—</span>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Club Information -->
                            <div class="stats-card mb-4">
                                <h3>Your Club</h3>
                                <div id="clubInfo">
                                    <div id="noClubSelected" style="display: none;">
                                        <button type="button" id="selectClubBtn" class="btn btn-outline-primary">
                                            <i class="fas fa-building me-2"></i>Select Club
                                        </button>
                                    </div>
                                    
                                    <div id="clubDetails" style="display: none;">
                                        <div class="d-flex justify-content-between align-items-start mb-3">
                                            <h4 id="clubName">—</h4>
                                            <button type="button" id="changeClubBtn" class="btn btn-sm btn-outline-primary">Change</button>
                                        </div>
                                        
                                        <div class="d-flex justify-content-between">
                                            <div>
                                                <p id="clubAddress" class="mb-1 text-muted">—</p>
                                                <p id="clubPostcode" class="mb-2 text-muted">—</p>
                                                <a id="clubWebsite" href="#" target="_blank">—</a>
                                            </div>
                                            
                                            <div class="d-flex align-items-center">
                                                <div id="clubPrimaryColor" class="rounded-circle me-2" style="width: 20px; height: 20px; background-color: #ccc;"></div>
                                                <div id="clubSecondaryColor" class="rounded-circle" style="width: 20px; height: 20px; background-color: #eee;"></div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Box League Tab -->
                <div class="tab-pane fade" id="boxleague" role="tabpanel" aria-labelledby="boxleague-tab">
                    <div class="box-league-container">
                        <div class="selector-area">
                            <div class="d-flex justify-content-between align-items-start mb-4">
                                <div id="statusFilter" class="mb-0">
                                    <!-- Status filter will be populated here -->
                                </div>
                                <button id="printLeagueBtn" class="btn btn-primary">
                                    <i class="fas fa-print me-1"></i> Print League Tables
                                </button>
                            </div>

                            <div id="leagueSelector" class="mb-4">
                                <!-- League selector will be populated here -->
                            </div>
                            
                            <div id="boxSelector" class="mb-4">
                                <!-- Box selector will be populated here -->
                            </div>
                        </div>
                        
                        <div id="leagueTableContainer" class="mb-4">
                            <!-- League table will be populated here -->
                        </div>
                        
                        <div class="row">
                            <div class="col-md-6">
                                <div class="stats-card">
                                    <h3>Upcoming Matches</h3>
                                    <div id="upcomingMatches" class="matches-container">
                                        <!-- Upcoming matches will be loaded here -->
                                        <p class="placeholder-text">Loading upcoming matches...</p>
                                    </div>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="stats-card">
                                    <h3>Match Results</h3>
                                    <div id="matchResults" class="matches-container">
                                        <!-- Match results will be loaded here -->
                                        <p class="placeholder-text">Loading match results...</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Stats Tab -->
                <div class="tab-pane fade" id="stats" role="tabpanel" aria-labelledby="stats-tab">
                    <div class="row">
                        <div class="col-md-12 mb-4">
                            <div class="stats-card">
                                <div class="d-flex justify-content-between align-items-center mb-3">
                                    <h3>Match History</h3>
                                    <div class="d-flex">
                                        <select id="matchHistoryFilter" class="form-select me-2">
                                            <option value="all">All Matches</option>
                                            <option value="my" selected>My Matches</option>
                                            <option value="club">My Club</option>
                                        </select>
                                        <select id="matchDateRangeFilter" class="form-select">
                                            <option value="7">Last 7 Days</option>
                                            <option value="30">Last 30 Days</option>
                                            <option value="90">Last 90 Days</option>
                                            <option value="180">Last 6 Months</option>
                                            <option value="365">Last Year</option>
                                            <option value="all">All Time</option>
                                        </select>
                                        <button id="toggleCustomDateBtn" class="btn btn-outline-light ms-2" title="Custom Date Range">
                                            <i class="fas fa-calendar-alt"></i>
                                        </button>
                                    </div>
                                </div>
                                
                                <!-- Custom date range selector (initially hidden) -->
                                <div id="customDateSelector" class="mb-3 p-3 rounded" style="display: none; background-color: rgba(255, 255, 255, 0.1);">
                                    <h6 class="mb-3">Custom Date Range</h6>
                                    <div class="row">
                                        <div class="col-md-6 mb-2">
                                            <label for="startDatePicker" class="form-label">Start Date</label>
                                            <input type="date" id="startDatePicker" class="form-control date-picker">
                                        </div>
                                        <div class="col-md-6 mb-2">
                                            <label for="endDatePicker" class="form-label">End Date</label>
                                            <input type="date" id="endDatePicker" class="form-control date-picker">
                                        </div>
                                    </div>
                                    <div class="d-flex justify-content-end mt-2">
                                        <button id="applyCustomDateBtn" class="btn btn-primary">Apply Date Range</button>
                                    </div>
                                </div>
                                
                                <!-- Searchbar for matches -->
                                <div class="input-group mb-3">
                                    <span class="input-group-text"><i class="fas fa-search"></i></span>
                                    <input type="text" id="matchSearchInput" class="form-control" placeholder="Search players...">
                                </div>
                                
                                <!-- Match history content -->
                                <div id="matchHistoryContent">
                                    <div id="matchesLoading" class="text-center py-4">
                                        <div class="spinner-border text-primary" role="status">
                                            <span class="visually-hidden">Loading matches...</span>
                                        </div>
                                        <p class="mt-2">Loading your match history...</p>
                                    </div>
                                    
                                    <div id="matchesEmpty" class="text-center py-4" style="display: none;">
                                        <i class="fas fa-trophy fa-3x mb-3 text-secondary"></i>
                                        <h4>No Matches Found</h4>
                                        <p class="text-muted">You don't have any recorded matches yet.</p>
                                    </div>
                                    
                                    <div id="matchesList" style="display: none;">
                                        <!-- Match results will be loaded here -->
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="col-md-4">
                            <div class="stats-card">
                                <h3>Match Statistics</h3>
                                <div id="matchStats">
                                    <!-- Match stats will be loaded here -->
                                </div>
                            </div>
                        </div>
                        <div class="col-md-4">
                            <div class="stats-card">
                                <h3>Recent Matches</h3>
                                <div id="recentMatches">
                                    <!-- Recent matches will be loaded here -->
                                </div>
                            </div>
                        </div>
                        <div class="col-md-4">
                            <div class="stats-card">
                                <h3>Box League Status</h3>
                                <div id="boxLeagueStatus">
                                    <!-- Box league status will be loaded here -->
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Settings Tab -->
                <div class="tab-pane fade" id="settings" role="tabpanel" aria-labelledby="settings-tab">
                    <div class="stats-card">
                        <h3>Account Settings</h3>
                        <div id="accountSettings">
                            <!-- Account settings will be loaded here -->
                            <p>Account settings coming soon.</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Authentication Test Section -->
            <div class="row mt-4" style="display: none;">
                <div class="col-12">
                    <div class="stats-card">
                        <h3>Authentication & Connection Test</h3>
                        <div id="connectionTest">
                            <div class="spinner" style="width: 20px; height: 20px;"></div>
                            <p>Testing connection...</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Footer container - will be filled by JavaScript -->
    <div id="footer-container"></div>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // Global variables
        let supabase;
        let debugInfoElement;
        let redirectAttempted = false; // Flag to prevent infinite loops
        let authRedirectTime = parseInt(localStorage.getItem('authRedirectTime') || '0');
        const currentTime = Date.now();
        
        // Add debug information
        function addDebugInfo(message) {
            console.log(message);  // Always log to console for developers
            // Don't add to visible debug area
        }

        
        // Show a loading message (now just logs to console)
        function showLoadingMessage(message, isError = false) {
            console.log(isError ? "Error: " : "Info: ", message);
        }

        
        // Initialize page elements
        document.addEventListener('DOMContentLoaded', function() {
            // Handle redirect loops
            if (currentTime - authRedirectTime < 5000) { // 5 seconds
                // We've been redirected too recently, show sign in button
                const goToAuthBtn = document.getElementById('goToAuth');
                if (goToAuthBtn) {
                    goToAuthBtn.style.display = 'block';
                    goToAuthBtn.addEventListener('click', function() {
                        window.location.href = '/auth.html';
                    });
                }

                console.log('Potential redirect loop detected. Staying on dashboard page.');
            }

            
            debugInfoElement = document.getElementById('debugInfo');
            
            // Set up button listeners
            document.getElementById('goToAuth').addEventListener('click', function() {
                window.location.href = '/auth.html';
            });
        
        });
        // Listen for the configLoaded event from config-loader.js
        document.addEventListener('configLoaded', function() {
            addDebugInfo('Configuration loaded successfully');
            addDebugInfo(`Supabase URL: ${window.config.supabaseUrl}`);
            addDebugInfo(`API key available: ${window.config.supabaseKey ? 'Yes' : 'No'}`);
            
            // Initialize Supabase with loaded configuration
            initializeDashboard();
        });
        
        // Main dashboard initialization function
        function initializeDashboard() {
            try {
                // Create Supabase client
                supabase = window.supabase.createClient(
                    window.config.supabaseUrl,
                    window.config.supabaseKey
                );
                
                if (!supabase || !supabase.auth) {
                    throw new Error('Failed to initialize Supabase client');
                }

                
                addDebugInfo('Supabase client initialized successfully');
                
                // Load user data
                loadUserData();
                
                // Setup sign out button
                document.getElementById('signOut').addEventListener('click', async (e) => {
                    e.preventDefault();
                    const { error } = await supabase.auth.signOut();
                    if (error) {
                        console.error('Error signing out:', error.message);
                    } else {
                        // Reset the redirect time tracker
                        localStorage.removeItem('authRedirectTime');
                        window.location.href = '/auth.html';
                    }

                });
            } catch (error) {
                console.error('Dashboard initialization error:', error);
                document.getElementById('goToAuth').style.display = 'block';
            }

        }

        
        // Check authentication and load user data
        async function loadUserData() {
            try {
                // Get session silently without showing status updates
                const { data: { session }, error: sessionError } = await supabase.auth.getSession();
                
                if (sessionError) {
                    throw sessionError;
                }

                
                if (!session) {
                    addDebugInfo('No active session found');
                    showLoadingMessage('You are not signed in. Redirecting to authentication page...', true);
                    
                    // Wait to display the message
                    setTimeout(() => {
                        if (!redirectAttempted) {
                            redirectAttempted = true;
                            localStorage.setItem('authRedirectTime', Date.now().toString());
                            window.location.href = '/auth.html';
                        }

                    }, 2000);
                    return;
                }

                
                addDebugInfo(`Session found for user: ${session.user.id}`);
                showLoadingMessage('Authentication successful! Loading your data...');
                
                try {
                    // Try to get the user profile
                    const { data: profile, error: profileError } = await supabase
                        .from('profiles')
                        .select('*')
                        .eq('id', session.user.id)
                        .single();
                    
                    if (profileError) {
                        addDebugInfo(`Profile fetch error: ${profileError.message}`);
                        // Even if profile fetch fails, show a basic dashboard with a friendly name
                        const userEmail = session.user.email || 'User';
                        const displayName = formatUserName(userEmail);
                        document.getElementById('userName').textContent = displayName;
                    } else {
                        // Log available profile fields for debugging
                        addDebugInfo(`Profile data: display_name=${profile.display_name}, full_name=${profile.full_name}`);
                        
                        // Update UI with user data - prioritize display_name, then full_name, then friendly email format
                        const displayName = profile.display_name || profile.full_name || formatUserName(session.user.email) || 'User';
                        document.getElementById('userName').textContent = displayName;
                        
                        // Log which field was used
                        if (profile.display_name) {
                            console.log('Using display_name for user:', profile.display_name);
                        } else if (profile.full_name) {
                            console.log('Using full_name for user:', profile.full_name);
                        } else {
                            console.log('Using formatted email for user:', formatUserName(session.user.email));
                        }

                        
                        addDebugInfo('Profile data loaded successfully');
                        
                        // Check if user is admin
                        const isAdmin = profile.is_admin === true;
                        addDebugInfo(`User is admin: ${isAdmin}`);
                        
                        // Store admin status for later use
                        window.userIsAdmin = isAdmin;
                    }

                    
                    // Load box league data
                    await loadBoxLeagueData(session.user.id);
                    
                    // We got this far, so authentication works
                    showBasicDashboard(session);
                    
                } catch (dataError) {
                    addDebugInfo(`Data loading error: ${dataError.message}`);
                    // If we fail to get profile but have a session, still show a basic dashboard
                    showBasicDashboard(session);
                }

            } catch (error) {
                console.error('Error checking authentication:', error);
                addDebugInfo(`Authentication error: ${error.message}`);
                document.getElementById('loadingDebug').style.display = 'block';
                document.getElementById('goToAuth').style.display = 'block';
                showLoadingMessage('Failed to authenticate. Please try signing in again.', true);
            }

        }

        
        // Helper function: Format email to a more user-friendly display name
        function formatUserName(email) {
            if (!email || typeof email !== 'string') return 'User';
            
            // Extract the part before @ if it's an email
            if (email.includes('@')) {
                const username = email.split('@')[0];
                
                // Handle common username patterns
                if (username.includes('.')) {
                    // Convert firstname.lastname to Firstname Lastname
                    return username.split('.')
                        .map(part => part.charAt(0).toUpperCase() + part.slice(1))
                        .join(' ');
                } else if (username.match(/[A-Z]/)) {
                    // Handle camelCase or PascalCase (e.g., johnDoe -> John Doe)
                    return username
                        .replace(/([A-Z])/g, ' $1')
                        .trim()
                        .split(' ')
                        .map(part => part.charAt(0).toUpperCase() + part.slice(1))
                        .join(' ');
                } else {
                    // Just capitalize the first letter
                    return username.charAt(0).toUpperCase() + username.slice(1);
                }

            }

            
            // Return original if not an email
            return email;
        }

        
        // Load Box League Data
        async function loadBoxLeagueData(userId) {
            try {
                // Check if user is admin (set in loadUserData)
                const isAdmin = window.userIsAdmin === true;
                // Log to console but don't show in UI
                addDebugInfo(`Loading box league data for ${isAdmin ? 'admin' : 'regular'} user`);
                
                // Get leagues
                // If RLS is properly set up, this will automatically filter to leagues the user has access to
                // Admins would see all leagues, regular users would see leagues they created or participate in
                const { data: leagues, error: leaguesError } = await supabase
                    .from('box_leagues')
                    .select('*')
                    .order('created_at', { ascending: false });
                
                if (leaguesError) {
                    throw leaguesError;
                }

                
                if (!leagues || leagues.length === 0) {
                    // Log to console but don't show in UI
                    addDebugInfo('No box leagues found');
                    
                    // Show message in league table container
                    document.getElementById('leagueTableContainer').innerHTML = `
                        <div class="alert alert-info">
                            <h4>No Box Leagues Available</h4>
                            <p>${isAdmin ? 
                                'There are no box leagues in the system yet.' : 
                                'You are not currently part of any box leagues.'}

                            </p>
                            ${!isAdmin ? `
                            <hr>
                            <p>This could be because:</p>
                            <ul>
                                <li>You haven't been added to any leagues yet</li>
                                <li>Your user account (${userId}) might not be correctly linked to your player profile</li>
                                <li>The leagues you're part of are not set as visible to you</li>
                            </ul>
                            <p>Please contact your league administrator for assistance.</p>` : ''}

                        </div>
                    `;
                    
                    document.getElementById('statusFilter').style.display = 'none';
                    document.getElementById('leagueSelector').style.display = 'none';
                    document.getElementById('boxSelector').style.display = 'none';
                    document.getElementById('upcomingMatches').innerHTML = '<p>No upcoming matches.</p>';
                    document.getElementById('matchResults').innerHTML = '<p>No match results available.</p>';
                    return;
                }

                
                // Try to verify if we really have access or if this is an RLS issue
                if (!isAdmin) {
                    // Check user's teams directly to verify data model connections
                    const { data: userTeams, error: userTeamsError } = await supabase
                        .from('box_league_teams')
                        .select('*')
                        .or(`player1_id.eq.${userId},player2_id.eq.${userId}`)
                        .limit(5);
                        
                    if (!userTeamsError && (!userTeams || userTeams.length === 0)) {
                        // Log to console but don't show in UI
                        addDebugInfo('User ID not found in any teams');
                        
                        // Add a warning to the league table container
                        document.getElementById('leagueTableContainer').insertAdjacentHTML('afterbegin', `
                            <div class="alert alert-warning mb-4">
                                <h4><i class="fas fa-exclamation-triangle me-2"></i> Possible Account Issue</h4>
                                <p>You can see leagues but aren't directly linked to any teams.</p>
                                <p>Your user ID (${userId}) doesn't match any player IDs in the system.</p>
                                <p>Contact your league administrator to verify your account is correctly set up.</p>
                            </div>
                        `);
                    }

                }

                
                // Log to console but don't show in UI
                addDebugInfo(`Found ${leagues.length} box leagues available to user`);
                
                // Create status filter
                createStatusFilter(leagues);
                
                // Default to showing active leagues
                filterLeaguesByStatus('active', leagues);
                
                // Set up print button
                setupPrintButton();
                
            } catch (error) {
                console.error('Error loading box league data:', error);
                // Log to console but don't show in UI
                addDebugInfo(`Box league data error: ${error.message}`);
                
                // Show a friendly error message
                document.getElementById('leagueTableContainer').innerHTML = `
                    <div class="alert alert-danger">
                        <h4>Unable to Load League Data</h4>
                        <p>There was a problem loading your box league data. Please try again later.</p>
                    </div>
                `;
                
                document.getElementById('upcomingMatches').innerHTML = '<p>Unable to load matches.</p>';
                document.getElementById('matchResults').innerHTML = '<p>Unable to load results.</p>';
            }

        }

        
        // Create status filter buttons
        function createStatusFilter(leagues) {
            const statusFilter = document.getElementById('statusFilter');
            
            // Extract all unique statuses from leagues
            const statuses = [...new Set(leagues.map(league => league.status || 'unknown'))];
            
            // Ensure we have our standard statuses, even if no leagues currently have them
            const standardStatuses = ['active', 'upcoming', 'completed', 'cancelled'];
            standardStatuses.forEach(status => {
                if (!statuses.includes(status)) {
                    statuses.push(status);
                }

            });
            
            // Get icons for each status
            const statusIcons = {
                active: '<i class="fas fa-play-circle me-1"></i>',
                upcoming: '<i class="fas fa-calendar-alt me-1"></i>',
                completed: '<i class="fas fa-flag-checkered me-1"></i>',
                cancelled: '<i class="fas fa-ban me-1"></i>',
                all: '<i class="fas fa-th-list me-1"></i>'
            };
            
            // Create filter buttons
            const filterHTML = `
                <label class="form-label d-block mb-2">Filter by Status:</label>
                <div class="status-filters">
                    <button class="status-filter-btn active" data-status="active">${statusIcons.active || ''}Active</button>
                    <button class="status-filter-btn" data-status="upcoming">${statusIcons.upcoming || ''}Upcoming</button>
                    <button class="status-filter-btn" data-status="completed">${statusIcons.completed || ''}Completed</button>
                    <button class="status-filter-btn" data-status="all">${statusIcons.all || ''}All</button>
                </div>
            `;
            
            statusFilter.innerHTML = filterHTML;
            
            // Add event listeners to filter buttons
            document.querySelectorAll('.status-filter-btn').forEach(button => {
                button.addEventListener('click', function() {
                    // Remove active class from all buttons
                    document.querySelectorAll('.status-filter-btn').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    
                    // Add active class to clicked button
                    this.classList.add('active');
                    
                    // Apply filter
                    const status = this.getAttribute('data-status');
                    filterLeaguesByStatus(status, leagues);
                });
            });
        }

        
        // Filter leagues by status and update the league selector
        function filterLeaguesByStatus(status, allLeagues) {
            let filteredLeagues;
            
            if (status === 'all') {
                filteredLeagues = allLeagues;
            } else {
                filteredLeagues = allLeagues.filter(league => 
                    league.status === status || 
                    // Handle case where status might be null or undefined
                    (status === 'active' && (!league.status || league.status === ''))
                );
            }

            
            // If no leagues match the filter, show a message
            if (filteredLeagues.length === 0) {
                document.getElementById('leagueSelector').innerHTML = `
                    <div class="alert alert-info">
                        No leagues found with status: ${status}

                    </div>
                `;
                document.getElementById('boxSelector').style.display = 'none';
                document.getElementById('leagueTableContainer').innerHTML = '';
                document.getElementById('upcomingMatches').innerHTML = '<p>No upcoming matches.</p>';
                document.getElementById('matchResults').innerHTML = '<p>No match results available.</p>';
                return;
            }

            
            // Create league selector with filtered leagues
            createLeagueSelector(filteredLeagues);
            
            // Load boxes for the first filtered league
            loadBoxesForLeague(filteredLeagues[0].id);
        }

        
        // Create league selector dropdown
        function createLeagueSelector(leagues) {
            const leagueSelector = document.getElementById('leagueSelector');
            
            const selectHTML = `
                <label for="leagueSelect" class="form-label">Select League:</label>
                <select id="leagueSelect" class="form-select" aria-label="Select a league">
                    ${leagues.map(league => {
                        const statusBadge = league.status ? 
                            `<span class="badge bg-${getStatusColor(league.status)}">${capitalizeFirstLetter(league.status)}</span>` : 
                            '';
                        return `<option value="${league.id}">${league.name || 'Unnamed League'} ${statusBadge}</option>`;
                    }).join('')}

                </select>
                <small class="form-text text-muted mt-1">Select a league to view its boxes and matches</small>
            `;
            
            leagueSelector.innerHTML = selectHTML;
            
            // Add event listener for change
            document.getElementById('leagueSelect').addEventListener('change', function() {
                loadBoxesForLeague(this.value);
            });
        }

        
        // Helper function to get color for status badge
        function getStatusColor(status) {
            switch (status.toLowerCase()) {
                case 'active': return 'success';
                case 'upcoming': return 'primary';
                case 'completed': return 'secondary';
                case 'cancelled': return 'danger';
                default: return 'info';
            }

        }

        
        // Helper function to capitalize first letter
        function capitalizeFirstLetter(string) {
            if (!string) return '';
            return string.charAt(0).toUpperCase() + string.slice(1);
        }

        
        // Load boxes for a specific league
        async function loadBoxesForLeague(leagueId) {
            try {
                console.log('Loading boxes for league ID:', leagueId);
                
                // Show loading indicator in box selector
                document.getElementById('boxSelector').innerHTML = `
                    <label for="boxSelect" class="form-label">Select Box:</label>
                    <div class="d-flex align-items-center">
                        <div class="spinner-border spinner-border-sm text-primary me-2" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                        <span>Loading boxes...</span>
                    </div>
                `;
                
                // Get boxes for the selected league
                const { data: boxes, error: boxesError } = await supabase
                    .from('box_league_boxes')
                    .select('*')
                    .eq('league_id', leagueId);
                
                if (boxesError) {
                    throw boxesError;
                }

                
                if (!boxes || boxes.length === 0) {
                    addDebugInfo('No boxes found for league');
                    document.getElementById('boxSelector').innerHTML = `
                        <div class="alert alert-info">
                            No boxes found for this league.
                        </div>
                    `;
                    document.getElementById('leagueTableContainer').innerHTML = `
                        <div class="alert alert-info">
                            <h4>No Box Data</h4>
                            <p>This league doesn't have any boxes configured yet.</p>
                        </div>
                    `;
                    document.getElementById('upcomingMatches').innerHTML = '<p>No upcoming matches.</p>';
                    document.getElementById('matchResults').innerHTML = '<p>No match results available.</p>';
                    return;
                }
                
                // Sort boxes alphabetically by name
                boxes.sort((a, b) => {
                    const aName = a.name || '';
                    const bName = b.name || '';
                    
                    // Natural sort algorithm (handles numeric parts properly)
                    return aName.localeCompare(bName, undefined, {numeric: true, sensitivity: 'base'});
                });
                
                // Create box selector
                createBoxSelector(boxes);
                
                // For the first box, get teams and matches
                await loadBoxDetails(boxes[0].id);
                
            } catch (error) {
                console.error('Error loading boxes for league:', error);
                document.getElementById('boxSelector').innerHTML = `
                    <div class="alert alert-danger">
                        <h4>Error Loading Boxes</h4>
                        <p>${error.message}</p>
                    </div>
                `;
                document.getElementById('leagueTableContainer').innerHTML = `
                    <div class="alert alert-danger">
                        Error loading boxes: ${error.message}

                    </div>
                `;
            }

        }

        
        // Create box selector dropdown
        function createBoxSelector(boxes) {
            const boxSelector = document.getElementById('boxSelector');
            
            const selectHTML = `
                <label for="boxSelect" class="form-label">Select Box:</label>
                <select id="boxSelect" class="form-select" aria-label="Select a box">
                    ${boxes.map(box => `<option value="${box.id}">${box.name || 'Unnamed Box'}</option>`).join('')}

                </select>
                <small class="form-text text-muted mt-1">Select a box to view teams and matches</small>
            `;
            
            boxSelector.innerHTML = selectHTML;
            
            // Add event listener for change
            document.getElementById('boxSelect').addEventListener('change', function() {
                loadBoxDetails(this.value);
            });
        }

        
        // Load details for a specific box
        async function loadBoxDetails(boxId) {
            try {
                console.log('Loading box details for box ID:', boxId);
                
                // Get teams for the box
                const { data: teams, error: teamsError } = await supabase
                    .from('box_league_teams')
                    .select('*')
                    .eq('box_id', boxId);
                
                if (teamsError) {
                    console.error('Error fetching teams:', teamsError);
                    throw teamsError;
                }

                
                console.log('Retrieved teams:', teams?.length || 0);
                console.log('Team data format sample:', JSON.stringify(teams.slice(0, 3), null, 2));
                
                // Get matches for the box
                const { data: matches, error: matchesError } = await supabase
                    .from('box_league_matches')
                    .select('*')
                    .eq('box_id', boxId);
                
                if (matchesError) {
                    console.error('Error fetching matches:', matchesError);
                    throw matchesError;
                }

                
                console.log('Retrieved matches:', matches?.length || 0);
                
                // Validate teams data
                if (!teams || !Array.isArray(teams)) {
                    throw new Error('Teams data is not valid: ' + JSON.stringify(teams));
                }

                
                // Validate team names
                teams.forEach((team, index) => {
                    if (!team.name) {
                        console.warn(`Team at index ${index} has no name:`, team);
                        team.name = `Team ${index + 1}`;
                    }

                });
                
                // Create league table
                createLeagueTable(teams, matches);
                
                // Create upcoming matches
                createUpcomingMatches(teams, matches);
                
                // Create match results
                createMatchResults(teams, matches);
                
            } catch (error) {
                console.error('Error loading box details:', error);
                document.getElementById('leagueTableContainer').innerHTML = `
                    <div class="alert alert-danger">
                        <h4>Error loading box details</h4>
                        <p>${error.message}</p>
                        <details>
                            <summary>Technical Details</summary>
                            <pre class="mt-2" style="font-size: 0.8rem; max-height: 150px; overflow: auto;">${error.stack || 'No stack trace available'}</pre>
                        </details>
                        <button class="btn btn-sm btn-outline-primary mt-3" onclick="window.location.reload()">Refresh Page</button>
                    </div>
                `;
                document.getElementById('upcomingMatches').innerHTML = '<p>Failed to load match data.</p>';
                document.getElementById('matchResults').innerHTML = '<p>Failed to load match data.</p>';
            }

        }

        
        // Create league table
        function createLeagueTable(teams, matches) {
            if (!teams || teams.length === 0) {
                document.getElementById('leagueTableContainer').innerHTML = '<p>No teams found for this box.</p>';
                return;
            }

            
            try {
                // Sort teams by calculated points
                const sortedTeams = teams.sort((a, b) => {
                    const pointsA = calculatePoints(a.id, matches);
                    const pointsB = calculatePoints(b.id, matches);
                    return pointsB - pointsA;
                });
                
                // Create table with headers
                let tableHTML = `
                    <div class="league-table">
                        <table>
                            <thead>
                                <tr>
                                    <th>Team</th>
                                    <th>Pts</th>
                                    ${sortedTeams.map(team => {
                                        try {
                                            return `<th>${getInitials(team)}</th>`;
                                        } catch (e) {
                                            console.error('Error in team header:', team, e);
                                            return '<th>??</th>';
                                        }

                                    }).join('')}

                                </tr>
                            </thead>
                            <tbody>
                `;
                
                // Create table rows
                sortedTeams.forEach((team, index) => {
                    try {
                        const playerNamesDisplay = getPlayerNames(team);
                        tableHTML += `
                            <tr>
                                <td class="team-name">${index + 1}. ${playerNamesDisplay}</td>
                                <td><strong>${calculatePoints(team.id, matches)}</strong></td>
                        `;
                        
                        // Create cells for each opponent
                        sortedTeams.forEach(opponent => {
                            try {
                                if (team.id === opponent.id) {
                                    tableHTML += '<td>—</td>';
                                } else {
                                    const matchResult = getMatchResult(team.id, opponent.id, matches);
                                    tableHTML += `<td>
                                        <div class="match-result ${matchResult.class}" 
                                             data-team1="${team.id}" 
                                             data-team2="${opponent.id}"
                                             data-match-id="${matchResult.matchId || ''}">
                                            ${matchResult.text}

                                        </div>
                                    </td>`;
                                }

                            } catch (e) {
                                console.error('Error in opponent cell:', team, opponent, e);
                                tableHTML += '<td>ERR</td>';
                            }

                        });
                        
                        tableHTML += '</tr>';
                    } catch (e) {
                        console.error('Error in team row:', team, e);
                        tableHTML += `<tr><td colspan="${2 + sortedTeams.length}">Error loading team data</td></tr>`;
                    }

                });
                
                tableHTML += `
                            </tbody>
                        </table>
                    </div>
                `;
                
                document.getElementById('leagueTableContainer').innerHTML = tableHTML;
                
                // Add event listeners to match-result divs
                document.querySelectorAll('.match-result').forEach(el => {
                    el.addEventListener('click', handleMatchClick);
                });
            } catch (error) {
                console.error('Error creating league table:', error);
                document.getElementById('leagueTableContainer').innerHTML = `
                    <div class="alert alert-danger">
                        <h4>Error creating league table</h4>
                        <p>${error.message}</p>
                        <pre class="mt-2" style="font-size: 0.8rem; max-height: 100px; overflow: auto;">${error.stack}</pre>
                    </div>
                `;
            }

        }

        
        // Create upcoming matches list
        function createUpcomingMatches(teams, matches) {
            // Filter for upcoming/scheduled matches
            const upcomingMatches = matches.filter(match => 
                !match.is_completed && match.scheduled_date
            );
            
            let upcomingHTML = '';
            
            if (upcomingMatches.length === 0) {
                upcomingHTML = '<p class="placeholder-text">No upcoming matches scheduled.</p>';
            } else {
                // Sort by date
                upcomingMatches.sort((a, b) => 
                    new Date(a.scheduled_date) - new Date(b.scheduled_date)
                );
                
                upcomingMatches.forEach(match => {
                    const team1 = teams.find(t => t.id === match.team1_id);
                    const team2 = teams.find(t => t.id === match.team2_id);
                    
                    if (team1 && team2) {
                        const team1Names = getPlayerNames(team1);
                        const team2Names = getPlayerNames(team2);
                        
                        upcomingHTML += `
                            <div class="match-card" data-match-id="${match.id}">
                                <div class="d-flex justify-content-between align-items-center">
                                    <div class="match-date">${formatDate(match.scheduled_date)}</div>
                                    <span class="match-status status-scheduled">Scheduled</span>
                                </div>
                                <div class="team-names">
                                    <div class="team">${team1Names}</div>
                                    <div class="vs">vs</div>
                                    <div class="team">${team2Names}</div>
                                </div>
                            </div>
                        `;
                    }

                });
            }

            
            document.getElementById('upcomingMatches').innerHTML = upcomingHTML;
            
            // Add event listeners
            document.querySelectorAll('#upcomingMatches .match-card').forEach(el => {
                el.addEventListener('click', () => {
                    const matchId = el.getAttribute('data-match-id');
                    handleMatchCardClick(matchId, matches, teams);
                });
            });
        }

        
        // Create match results list
        function createMatchResults(teams, matches) {
            // Filter for completed matches
            const completedMatches = matches.filter(match => match.is_completed);
            
            let resultsHTML = '';
            
            if (completedMatches.length === 0) {
                resultsHTML = '<p class="placeholder-text">No completed matches yet.</p>';
            } else {
                // Sort by date, most recent first
                completedMatches.sort((a, b) => 
                    new Date(b.completed_date || b.scheduled_date) - new Date(a.completed_date || a.scheduled_date)
                );
                
                completedMatches.forEach(match => {
                    const team1 = teams.find(t => t.id === match.team1_id);
                    const team2 = teams.find(t => t.id === match.team2_id);
                    
                    if (team1 && team2) {
                        const team1Names = getPlayerNames(team1);
                        const team2Names = getPlayerNames(team2);
                        const team1Score = match.team1_score;
                        const team2Score = match.team2_score;
                        const team1SetScores = match.team1_set_scores || [];
                        const team2SetScores = match.team2_set_scores || [];
                        
                        resultsHTML += `
                            <div class="match-card" data-match-id="${match.id}">
                                <div class="d-flex justify-content-between align-items-center">
                                    <div class="match-date">${formatDate(match.completed_date || match.scheduled_date)}</div>
                                    ${match.is_walkover ? 
                                        '<span class="match-status status-walkover">Walkover</span>' : 
                                        '<span class="match-status status-completed">Completed</span>'}

                                </div>
                                <div class="team-names">
                                    <div class="team">${team1Names}</div>
                                    <div class="score">${team1Score} - ${team2Score}</div>
                                    <div class="team">${team2Names}</div>
                                </div>
                                ${formatSetScores(team1SetScores, team2SetScores)}

                            </div>
                        `;
                    }

                });
            }

            
            document.getElementById('matchResults').innerHTML = resultsHTML;
            
            // Add event listeners
            document.querySelectorAll('#matchResults .match-card').forEach(el => {
                el.addEventListener('click', () => {
                    const matchId = el.getAttribute('data-match-id');
                    handleMatchCardClick(matchId, matches, teams);
                });
            });
        }

        
        // Handle match click in league table
        function handleMatchClick(event) {
            const team1Id = this.getAttribute('data-team1');
            const team2Id = this.getAttribute('data-team2');
            const matchId = this.getAttribute('data-match-id');
            
            console.log(`Match clicked: ${team1Id} vs ${team2Id}, match ID: ${matchId}`);
            
            // TODO: Open match details modal or form
            alert(`Match detail view coming soon for ${team1Id} vs ${team2Id}`);
        }

        
        // Handle match card click
        function handleMatchCardClick(matchId, matches, teams) {
            const match = matches.find(m => m.id === matchId);
            
            if (!match) return;
            
            const team1 = teams.find(t => t.id === match.team1_id);
            const team2 = teams.find(t => t.id === match.team2_id);
            
            if (!team1 || !team2) return;
            
            const team1Names = getPlayerNames(team1);
            const team2Names = getPlayerNames(team2);
            
            console.log(`Match card clicked: ${team1Names} vs ${team2Names}`);
            
            // TODO: Open match details modal or form
            alert(`Match detail view coming soon for ${team1Names} vs ${team2Names}`);
        }

        
        // Helper function: Get match result for display in the grid
        function getMatchResult(team1Id, team2Id, matches) {
            // Find match between these teams
            const match = matches.find(m => 
                (m.team1_id === team1Id && m.team2_id === team2Id) || 
                (m.team1_id === team2Id && m.team2_id === team1Id)
            );
            
            if (!match) {
                // No match exists
                return { text: '+', class: 'match-unplayed', matchId: null };
            }

            
            if (!match.is_completed) {
                // Match exists but not completed
                if (match.scheduled_date) {
                    return { text: '⏰', class: 'match-scheduled', matchId: match.id };
                } else {
                    return { text: '+', class: 'match-unplayed', matchId: match.id };
                }

            }

            
            // Match is completed
            // Check if it's a walkover
            if (match.is_walkover) {
                // Determine if this team won the walkover
                const isWinner = (match.team1_id === team1Id && match.team1_score > match.team2_score) ||
                                (match.team2_id === team1Id && match.team2_score > match.team1_score);
                
                if (isWinner) {
                    return { text: 'WO', class: 'match-walkover-win', matchId: match.id };
                } else {
                    return { text: 'WO', class: 'match-walkover-loss', matchId: match.id };
                }

            }

            
            // Regular completed match
            const isWinner = (match.team1_id === team1Id && match.team1_score > match.team2_score) ||
                            (match.team2_id === team1Id && match.team2_score > match.team1_score);
            
            if (isWinner) {
                return { text: 'W', class: 'match-win', matchId: match.id };
            } else {
                return { text: 'L', class: 'match-loss', matchId: match.id };
            }

        }

        
        // Helper function: Calculate points for a team
        function calculatePoints(teamId, matches) {
            let points = 0;
            
            // Filter for matches involving this team and that are completed
            const teamMatches = matches.filter(match => 
                (match.team1_id === teamId || match.team2_id === teamId) && match.is_completed
            );
            
            for (const match of teamMatches) {
                const isTeam1 = match.team1_id === teamId;
                
                // Special handling for walkover matches
                if (match.is_walkover) {
                    // For walkover, winning team gets 4 points, losing team gets 0
                    if ((isTeam1 && match.team1_score > match.team2_score) || 
                        (!isTeam1 && match.team2_score > match.team1_score)) {
                        points += 4;
                    }

                    continue;
                }

                
                // Get set scores if available
                const team1Sets = match.team1_set_scores || [];
                const team2Sets = match.team2_set_scores || [];
                
                if (team1Sets.length === 0 || team2Sets.length === 0) {
                    // Fall back to match score if set scores are missing
                    if (isTeam1) {
                        if (match.team1_score > match.team2_score) {
                            points += 4; // Default points for win
                        } else {
                            points += 1; // Default points for loss
                        }

                    } else {
                        if (match.team2_score > match.team1_score) {
                            points += 4; // Default points for win
                        } else {
                            points += 1; // Default points for loss
                        }

                    }

                    continue;
                }

                
                // Count sets won by each team
                let team1SetsWon = 0;
                let team2SetsWon = 0;
                
                for (let i = 0; i < Math.min(team1Sets.length, team2Sets.length); i++) {
                    if (team1Sets[i] > team2Sets[i]) {
                        team1SetsWon++;
                    } else if (team2Sets[i] > team1Sets[i]) {
                        team2SetsWon++;
                    }

                }

                
                // Apply scoring system
                if (isTeam1) {
                    if (team1SetsWon === 2 && team2SetsWon === 0) {
                        points += 5; // 2-0 win
                    } else if (team1SetsWon === 2 && team2SetsWon === 1) {
                        points += 4; // 2-1 win
                    } else if (team1SetsWon === 1 && team2SetsWon === 2) {
                        points += 2; // 1-2 loss
                    } else if (team1SetsWon === 0 && team2SetsWon === 2) {
                        points += 1; // 0-2 loss
                    }

                } else {
                    if (team2SetsWon === 2 && team1SetsWon === 0) {
                        points += 5; // 2-0 win
                    } else if (team2SetsWon === 2 && team1SetsWon === 1) {
                        points += 4; // 2-1 win
                    } else if (team2SetsWon === 1 && team1SetsWon === 2) {
                        points += 2; // 1-2 loss
                    } else if (team2SetsWon === 0 && team1SetsWon === 2) {
                        points += 1; // 0-2 loss
                    }

                }

            }

            
            return points;
        }

        
        // Helper function: Get player names display from team object
        function getPlayerNames(team) {
            if (!team) return 'Unknown Team';
            
            try {
                // Log the actual team object we're processing for debugging
                console.log('Processing team:', team);
                
                // If we have a team object with player names fields
                if (team.player1_name || team.player2_name) {
                    const player1 = extractFirstName(team.player1_name || '');
                    
                    // If there's no player2, just return player1
                    if (!team.player2_name) {
                        return player1 || team.name || 'Unknown';
                    }

                    
                    const player2 = extractFirstName(team.player2_name || '');
                    return `${player1} & ${player2}`;
                }

                
                // If we just have a team name string (legacy support)
                if (typeof team === 'string') {
                    return team;
                }

                
                // If we have a team object with just a name field
                return team.name || 'Unknown Team';
            } catch (error) {
                console.error('Error extracting player names:', error);
                // Return whatever name is available
                return team.name || 'Unknown Team';
            }

        }

        
        // Helper function to extract first name from a full name
        function extractFirstName(fullName) {
            if (!fullName) return '';
            
            // Handle names with ratings in parentheses like "John Smith (5.0)"
            const nameWithoutRating = fullName.replace(/\s*\([^)]*\)\s*$/, '');
            
            // Get first word as first name
            const parts = nameWithoutRating.trim().split(' ');
            return parts[0] || '';
        }

        
        // Helper function: Get initials for table header
        function getInitials(team) {
            if (!team) return 'NA';
            
            try {
                // If we have a team object with player names fields
                if (team.player1_name || team.player2_name) {
                    const player1 = extractFirstName(team.player1_name || '');
                    
                    // If there's no player2, just return player1 initials
                    if (!team.player2_name) {
                        return player1.substring(0, 3) || 'NA';
                    }

                    
                    const player2 = extractFirstName(team.player2_name || '');
                    // Format: first 2 chars of each name
                    return `${player1.substring(0, 2)}/${player2.substring(0, 2)}`;
                }

                
                // Legacy support for cases where we receive just a name string
                if (typeof team === 'string') {
                    const name = team;
                    // Handle "Team X" format by just showing the number
                    const teamMatch = name.match(/^Team\s+(\d+)$/i);
                    if (teamMatch) {
                        return `T${teamMatch[1]}`;
                    }

                    
                    // Try splitting by common separators
                    if (name.includes(' & ')) {
                        const parts = name.split(' & ');
                        return `${parts[0][0]}${parts[1][0]}`.toUpperCase();
                    } else if (name.includes('-')) {
                        const parts = name.split('-');
                        return `${parts[0][0]}${parts[1][0]}`.toUpperCase();
                    } else if (name.includes('/')) {
                        const parts = name.split('/');
                        return `${parts[0][0]}${parts[1][0]}`.toUpperCase();
                    }

                    
                    // Fall back to first 2 characters
                    return name.substring(0, 2).toUpperCase();
                }

                
                // If we have a team object with just a name field
                if (team.name) {
                    return team.name.substring(0, 2).toUpperCase();
                }

                
                return 'NA';
            } catch (error) {
                console.error('Error getting initials from team:', error);
                return 'NA';
            }

        }

        
        // Helper function: Format date
        function formatDate(dateString) {
            if (!dateString) return 'Date not set';
            
            const date = new Date(dateString);
            return date.toLocaleString('en-US', { 
                month: 'short', 
                day: 'numeric', 
                year: 'numeric',
                hour: 'numeric',
                minute: '2-digit'
            });
        }

        
        // Helper function: Format set scores
        function formatSetScores(team1Sets, team2Sets) {
            if (!team1Sets || !team2Sets || team1Sets.length === 0 || team2Sets.length === 0) {
                return '';
            }

            
            const setScores = [];
            for (let i = 0; i < Math.min(team1Sets.length, team2Sets.length); i++) {
                setScores.push(`${team1Sets[i]}-${team2Sets[i]}`);
            }

            
            return `<div class="set-scores text-center mt-1 text-secondary">Sets: ${setScores.join(', ')}</div>`;
        }

        
        // Handle print league tables button
        function setupPrintButton() {
            const printButton = document.getElementById('printLeagueBtn');
            if (printButton) {
                printButton.addEventListener('click', async function() {
                    try {
                        // Get selected league ID
                        const leagueSelect = document.getElementById('leagueSelect');
                        if (!leagueSelect) {
                            alert('Please select a league first');
                            return;
                        }

                        
                        const leagueId = leagueSelect.value;
                        const leagueName = leagueSelect.options[leagueSelect.selectedIndex].text;
                        
                        // Show loading spinner
                        printButton.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Preparing...';
                        printButton.disabled = true;
                        
                        // Get all boxes for this league
                        const { data: boxes, error: boxesError } = await supabase
                            .from('box_league_boxes')
                            .select('*')
                            .eq('league_id', leagueId);
                        
                        if (boxesError) throw boxesError;
                        if (!boxes || boxes.length === 0) {
                            alert('No boxes found for this league');
                            return;
                        }

                        
                        // Sort boxes alphanumerically by name
                        boxes.sort((a, b) => {
                            // Extract numbers from box names (if they exist)
                            const aName = a.name || '';
                            const bName = b.name || '';
                            
                            // Natural sort algorithm
                            return aName.localeCompare(bName, undefined, {numeric: true, sensitivity: 'base'});
                        });
                        
                        // Create print window content
                        let printContent = `
                            <!DOCTYPE html>
                            <html>
                            <head>
                                <title>${leagueName} - Box League Tables</title>
                                <style>
                                    /* Print-specific styling - won't affect main website */
                                    @page { 
                                        size: portrait;
                                        margin: 0.5cm;
                                    }

                                    
                                    body { 
                                        font-family: Arial, sans-serif; 
                                        margin: 10px;
                                        font-size: 10px;
                                        line-height: 1.3;
                                    }

                                    
                                    h1 { 
                                        text-align: center; 
                                        margin-bottom: 10px;
                                        font-size: 16px;
                                        margin-top: 0;
                                    }

                                    
                                    h2 {
                                        font-size: 14px;
                                        margin: 6px 0;
                                    }

                                    
                                    .box-container { 
                                        margin-bottom: 12px; 
                                        page-break-inside: avoid; 
                                    }

                                    
                                    table { 
                                        width: 100%; 
                                        border-collapse: collapse; 
                                        margin-bottom: 8px;
                                        table-layout: fixed;
                                    }

                                    
                                    th, td { 
                                        border: 1px solid #ddd; 
                                        padding: 3px 2px; 
                                        text-align: center;
                                        font-size: 9px;
                                        overflow: hidden;
                                        white-space: nowrap;
                                        text-overflow: ellipsis;
                                    }

                                    
                                    th:first-child, td:first-child { 
                                        text-align: left; 
                                        padding-left: 4px;
                                        width: 25%;
                                    }

                                    
                                    th:nth-child(2), td:nth-child(2) {
                                        width: 8%;
                                    }

                                    
                                    th { 
                                        background-color: #f2f2f2; 
                                        font-weight: bold;
                                    }

                                    
                                    .team-name { 
                                        font-weight: normal;
                                        max-width: 180px;
                                        overflow: hidden;
                                        text-overflow: ellipsis;
                                    }

                                    
                                    .points { 
                                        font-weight: bold; 
                                        background-color: #f8f9fa;
                                    }

                                    
                                    .match-result { 
                                        width: 16px; 
                                        height: 16px; 
                                        border-radius: 50%; 
                                        margin: 0 auto;
                                        display: flex;
                                        align-items: center;
                                        justify-content: center;
                                        font-weight: bold;
                                        font-size: 8px;
                                    }

                                    
                                    .match-win { 
                                        background-color: #a3e4b7; 
                                        color: #0a6522;
                                    }

                                    
                                    .match-loss { 
                                        background-color: #f8c1c7; 
                                        color: #7a1520;
                                    }

                                    
                                    .match-unplayed { 
                                        background-color: #e2e2e2; 
                                        color: #555555;
                                    }

                                    
                                    .match-scheduled { 
                                        background-color: #b8daff; 
                                        color: #004085;
                                    }

                                    
                                    .match-walkover-win { 
                                        background-color: #b3d3ff; 
                                        color: #002a66;
                                    }

                                    
                                    .match-walkover-loss { 
                                        background-color: #fff3cd; 
                                        color: #745800;
                                    }

                                    
                                    .print-footer {
                                        position: fixed;
                                        bottom: 0;
                                        width: 100%;
                                        text-align: center;
                                    }

                                    
                                    .legend {
                                        margin: 5px 0;
                                        display: flex;
                                        flex-wrap: wrap;
                                        justify-content: center;
                                        gap: 5px;
                                        font-size: 8px;
                                    }

                                    
                                    .legend-item {
                                        display: flex;
                                        align-items: center;
                                        margin-right: 5px;
                                    }

                                    
                                    .legend-marker {
                                        width: 14px;
                                        height: 14px;
                                        border-radius: 50%;
                                        margin-right: 3px;
                                        display: inline-flex;
                                        align-items: center;
                                        justify-content: center;
                                        font-weight: bold;
                                        font-size: 8px;
                                    }

                                </style>
                            </head>
                            <body>
                                <h1>${leagueName} - Box League Tables</h1>
                                
                                <div class="legend">
                                    <div class="legend-item">
                                        <div class="legend-marker match-win">W</div>
                                        <span>Win</span>
                                    </div>
                                    <div class="legend-item">
                                        <div class="legend-marker match-loss">L</div>
                                        <span>Loss</span>
                                    </div>
                                    <div class="legend-item">
                                        <div class="legend-marker match-unplayed">+</div>
                                        <span>Not Played</span>
                                    </div>
                                    <div class="legend-item">
                                        <div class="legend-marker match-scheduled">⏰</div>
                                        <span>Scheduled</span>
                                    </div>
                                    <div class="legend-item">
                                        <div class="legend-marker match-walkover-win">WO</div>
                                        <span>Walkover</span>
                                    </div>
                                </div>
                        `;
                        
                        // Process each box
                        const processedBoxes = [];
                        
                        for (const box of boxes) {
                            // Get teams for this box
                            const { data: teams, error: teamsError } = await supabase
                                .from('box_league_teams')
                                .select('*')
                                .eq('box_id', box.id);
                                
                            if (teamsError) {
                                console.error('Error fetching teams:', teamsError);
                                continue;
                            }

                            
                            if (!teams || teams.length === 0) continue;
                            
                            // Get matches for this box
                            const { data: matches, error: matchesError } = await supabase
                                .from('box_league_matches')
                                .select('*')
                                .eq('box_id', box.id);
                                
                            if (matchesError) {
                                console.error('Error fetching matches:', matchesError);
                                continue;
                            }

                            
                            // Sort teams by calculated points
                            const sortedTeams = teams.sort((a, b) => {
                                const pointsA = calculatePoints(a.id, matches);
                                const pointsB = calculatePoints(b.id, matches);
                                return pointsB - pointsA;
                            });
                            
                            // Create table HTML
                            let tableHTML = `
                                <div class="box-container">
                                    <h2>${box.name || 'Unnamed Box'}</h2>
                                    <table>
                                        <thead>
                                            <tr>
                                                <th>Team</th>
                                                <th>Pts</th>
                                                ${sortedTeams.map(team => {
                                                    try {
                                                        return `<th>${getInitials(team)}</th>`;
                                                    } catch (e) {
                                                        return '<th>??</th>';
                                                    }

                                                }).join('')}

                                            </tr>
                                        </thead>
                                        <tbody>
                            `;
                            
                            // Create table rows
                            sortedTeams.forEach((team, index) => {
                                try {
                                    const playerNamesDisplay = getPlayerNames(team);
                                    tableHTML += `
                                        <tr>
                                            <td class="team-name">${index + 1}. ${playerNamesDisplay}</td>
                                            <td class="points">${calculatePoints(team.id, matches)}</td>
                                    `;
                                    
                                    // Create cells for each opponent
                                    sortedTeams.forEach(opponent => {
                                        try {
                                            if (team.id === opponent.id) {
                                                tableHTML += '<td>—</td>';
                                            } else {
                                                const matchResult = getMatchResult(team.id, opponent.id, matches);
                                                tableHTML += `<td>
                                                    <div class="match-result ${matchResult.class}">
                                                        ${matchResult.text}

                                                    </div>
                                                </td>`;
                                            }

                                        } catch (e) {
                                            tableHTML += '<td>ERR</td>';
                                        }

                                    });
                                    
                                    tableHTML += '</tr>';
                                } catch (e) {
                                    tableHTML += `<tr><td colspan="${2 + sortedTeams.length}">Error loading team data</td></tr>`;
                                }

                            });
                            
                            tableHTML += `
                                        </tbody>
                                    </table>
                                </div>
                            `;
                            
                            processedBoxes.push(tableHTML);
                        }

                        
                        // Add all tables to the print content
                        printContent += processedBoxes.join('');
                        
                        // Close HTML
                        printContent += `
                                <div style="text-align: center; margin-top: 10px; color: #666; font-size: 7px;">
                                    Padel Pals Box League | ${new Date().toLocaleDateString()}

                                </div>
                            </body>
                            </html>
                        `;
                        
                        // Open print window
                        const printWindow = window.open('', '_blank');
                        printWindow.document.write(printContent);
                        printWindow.document.close();
                        
                        // Wait for resources to load then print
                        printWindow.onload = function() {
                            printWindow.print();
                        };
                        
                    } catch (error) {
                        console.error('Error preparing print view:', error);
                        alert('There was an error preparing the print view: ' + error.message);
                    } finally {
                        // Reset button
                        printButton.innerHTML = '<i class="fas fa-print me-1"></i> Print League Tables';
                        printButton.disabled = false;
                    }

                });
            }

        }

        
        // Show a basic dashboard even if profile data fails
        function showBasicDashboard(session) {
            // Set placeholder content
            document.getElementById('matchStats').innerHTML = '<p>Your match data is not available yet.</p>';
            document.getElementById('recentMatches').innerHTML = '<p>No recent matches found.</p>';
            document.getElementById('boxLeagueStatus').innerHTML = '<p>Box league data is not available yet.</p>';
            
            // Still run the connection test silently in the background 
            // to verify connectivity without showing the UI
            testSupabaseConnection(session);
            
            // Initialize profile tab
            initializeProfileTab(session);
            
            // Show dashboard content
            document.getElementById('loading').style.display = 'none';
            document.getElementById('dashboardContent').style.display = 'block';
        }
        
        // Initialize the profile tab with user data
        async function initializeProfileTab(session) {
            try {
                // Load player profile data
                const userId = session.user.id;
                console.log("Initializing profile tab for user:", userId);
                
                // Set user name from session initially
                document.getElementById('playerName').value = formatUserName(session.user.email);
                
                // Fetch profile data the same way Swift app does
                try {
                    // Create the combined profile endpoint that includes clubs and ratings
                    const profileEndpoint = `${window.config.supabaseUrl}/rest/v1/user_profiles?id=eq.${userId}&select=*,clubs(*),ratings_coach(*)`;
                    
                    console.log("Fetching profile from endpoint:", profileEndpoint);
                    
                    // Set up headers for the request
                    const headers = {
                        'Content-Type': 'application/json',
                        'apikey': window.config.supabaseKey,
                        'Authorization': `Bearer ${session.access_token}`
                    };
                    
                    // Make the request
                    const response = await fetch(profileEndpoint, {
                        method: 'GET',
                        headers: headers
                    });
                    
                    if (!response.ok) {
                        throw new Error(`Profile fetch failed with status: ${response.status}`);
                    }
                    
                    const profileData = await response.json();
                    console.log("Profile data:", profileData);
                    
                    if (profileData && profileData.length > 0) {
                        const profile = profileData[0];
                        
                        // Update name if available
                        if (profile.display_name) {
                            document.getElementById('playerName').value = profile.display_name;
                            document.getElementById('userName').textContent = profile.display_name;
                        } else if (profile.full_name) {
                            document.getElementById('playerName').value = profile.full_name;
                            document.getElementById('userName').textContent = profile.full_name;
                        } else if (session.user && session.user.email) {
                            const formatted = formatUserName(session.user.email);
                            document.getElementById('playerName').value = formatted;
                            document.getElementById('userName').textContent = formatted;
                        } else {
                            document.getElementById('playerName').value = 'User';
                            document.getElementById('userName').textContent = 'User';
                        }
                        
                        // Get club information
                        const club = profile.clubs;
                        if (club) {
                            // Hide no club message, show club details
                            document.getElementById('noClubSelected').style.display = 'none';
                            document.getElementById('clubDetails').style.display = 'block';
                            
                            // Update club information
                            document.getElementById('clubName').textContent = club.club_name || club.name || '—';
                            document.getElementById('clubAddress').textContent = club.club_address || club.address || '';
                            document.getElementById('clubPostcode').textContent = club.club_postcode || club.postcode || '';
                            
                            if (club.club_website || club.website) {
                                const websiteLink = document.getElementById('clubWebsite');
                                websiteLink.href = club.club_website || club.website;
                                websiteLink.textContent = club.club_website || club.website;
                            }
                            
                            // Update club colors
                            if (club.primary_color) {
                                document.getElementById('clubPrimaryColor').style.backgroundColor = club.primary_color;
                            } else if (club.primaryColor) {
                                document.getElementById('clubPrimaryColor').style.backgroundColor = club.primaryColor;
                            }
                            
                            if (club.secondary_color) {
                                document.getElementById('clubSecondaryColor').style.backgroundColor = club.secondary_color;
                            } else if (club.secondaryColor) {
                                document.getElementById('clubSecondaryColor').style.backgroundColor = club.secondaryColor;
                            }
                        } else {
                            // No club selected
                            document.getElementById('noClubSelected').style.display = 'block';
                            document.getElementById('clubDetails').style.display = 'none';
                        }
                        
                        // Get ratings data
                        const ratings = profile.ratings_coach;
                        if (ratings && ratings.length > 0) {
                            // Sort ratings by date in descending order
                            const sortedRatings = ratings.sort((a, b) => {
                                return new Date(b.date) - new Date(a.date);
                            });
                            
                            const latestRating = sortedRatings[0];
                            
                            // Update player rating
                            if (latestRating.rating) {
                                document.getElementById('playerRating').textContent = latestRating.rating.toFixed(1);
                            }
                            
                            // Update category
                            if (latestRating.category) {
                                document.getElementById('playerCategory').textContent = latestRating.category;
                                
                                // Set category definition
                                const categoryDefinitions = {
                                    "Newcomer": "First time playing, learning basic rules and how to hit the ball.",
                                    "Beginner": "Can rally a little, but struggles with control, positioning, and timing.",
                                    "Improver": "More consistent shots, starting to understand walls and basic tactics.",
                                    "Lower Intermediate": "Can sustain rallies, control pace better, and use walls more effectively.",
                                    "Intermediate": "Good shot control, understands positioning, and can start dictating play.",
                                    "Upper Intermediate": "Confident play, good use of lobs, angles, and teamwork.",
                                    "Advanced": "Strong tactical awareness, consistent under pressure, and adapts well to opponents.",
                                    "Competitive": "High-level player, effective in attack and defense, plays structured points.",
                                    "Elite": "Tournament-level, excels in all aspects of the game with precision and strategy."
                                };
                                
                                if (categoryDefinitions[latestRating.category]) {
                                    document.getElementById('categoryDefinition').textContent = categoryDefinitions[latestRating.category];
                                }
                            }
                            
                            // Update assessment date
                            if (latestRating.date) {
                                const assessmentDate = new Date(latestRating.date);
                                document.getElementById('assessmentDate').textContent = assessmentDate.toLocaleDateString();
                            }
                            
                            // Update coach name
                            if (latestRating.coach_name || latestRating.assessor) {
                                document.getElementById('assessedBy').textContent = latestRating.coach_name || latestRating.assessor;
                            }
                        }
                    }
                    
                    // Now get match ratings separately using the correct endpoint (matches Swift app)
                    const ratingsEndpoint = `${window.config.supabaseUrl}/rest/v1/ratings?id=eq.${userId}&select=rating_0_10,confidence_pct,date&order=date.desc&limit=1`;
                    
                    console.log("Fetching match ratings from:", ratingsEndpoint);
                    
                    const ratingsResponse = await fetch(ratingsEndpoint, {
                        method: 'GET',
                        headers: headers
                    });
                    
                    if (ratingsResponse.ok) {
                        const matchRatings = await ratingsResponse.json();
                        console.log("Match ratings data:", matchRatings);
                        
                        if (matchRatings && matchRatings.length > 0) {
                            const latestMatchRating = matchRatings[0];
                            
                            if (latestMatchRating.rating_0_10) {
                                document.getElementById('matchRating').textContent = latestMatchRating.rating_0_10.toFixed(1);
                            }
                            
                            if (latestMatchRating.confidence_pct) {
                                document.getElementById('ratingConfidence').textContent = 
                                    (latestMatchRating.confidence_pct * 100).toFixed(1) + '%';
                            }
                        }
                    } else {
                        console.warn("Failed to fetch match ratings:", ratingsResponse.status);
                    }
                } catch (error) {
                    console.error('Error loading profile details:', error);
                }
                
                // Set up profile button handlers
                setupProfileButtonHandlers(session);
                
            } catch (error) {
                console.error('Error initializing profile tab:', error);
            }
        }
        
        // Set up button handlers for the profile tab
        function setupProfileButtonHandlers(session) {
            // Edit name button
            const editNameBtn = document.getElementById('editNameBtn');
            const playerNameInput = document.getElementById('playerName');
            
            editNameBtn.addEventListener('click', function() {
                if (playerNameInput.disabled) {
                    // Enable editing
                    playerNameInput.disabled = false;
                    editNameBtn.textContent = 'Save';
                    playerNameInput.focus();
                } else {
                    // Save changes
                    const newName = playerNameInput.value.trim();
                    if (newName) {
                        saveUserName(session.user.id, newName);
                    }
                    playerNameInput.disabled = true;
                    editNameBtn.textContent = 'Edit';
                }
            });
            
            // Refresh rating button
            document.getElementById('refreshRatingBtn').addEventListener('click', function() {
                refreshUserProfile(session.user.id);
            });
            
            // Select club button
            document.getElementById('selectClubBtn').addEventListener('click', function() {
                alert('Club selection functionality coming soon!');
                // TODO: Implement club selection modal
            });
            
            // Change club button
            document.getElementById('changeClubBtn').addEventListener('click', function() {
                alert('Club change functionality coming soon!');
                // TODO: Implement club change modal
            });
            
            // View rating trend button
            document.getElementById('viewRatingTrendBtn').addEventListener('click', function() {
                const chartContainer = document.getElementById('ratingTrendContainer');
                if (chartContainer.style.display === 'none') {
                    // Show the chart and load data
                    chartContainer.style.display = 'block';
                    this.innerHTML = '<i class="fas fa-chevron-up me-2"></i>Hide Rating Trend';
                    loadRatingTrendData(session.user.id);
                } else {
                    // Hide the chart
                    chartContainer.style.display = 'none';
                    this.innerHTML = '<i class="fas fa-chart-line me-2"></i>View Rating Trend';
                }
            });
            
            // Time range selector
            document.getElementById('timeRangeSelector').addEventListener('change', function() {
                // Re-filter data based on selected time range
                const userId = session.user.id;
                loadRatingTrendData(userId, true); // true = use cached data if available
            });
        }

        // Chart and rating trend data variables
        let ratingChart = null;
        let ratingTrendData = null;

        // Load rating trend data
        async function loadRatingTrendData(userId, useCache = false) {
            try {
                console.log("Starting to load rating trend data for user:", userId);
                
                // Show loading state on chart
                const chartCanvas = document.getElementById('ratingChart');
                const chartContainer = chartCanvas.parentElement;
                
                // Check if we should use cached data
                if (useCache && ratingTrendData) {
                    console.log("Using cached rating data");
                    updateRatingChart(ratingTrendData);
                    return;
                }
                
                // Show loading indicator
                chartContainer.innerHTML = '<div class="d-flex justify-content-center align-items-center h-100"><div class="spinner-border text-primary" role="status"></div></div>';
                
                // Get current session and access token - similar to Swift code
                const { data: { session } } = await supabase.auth.getSession();
                if (!session) {
                    throw new Error('No active session found');
                }
                
                const accessToken = session.access_token;
                console.log("Got access token:", accessToken ? "Valid token" : "No token");
                
                // Create the request to fetch rating history - exactly like Swift implementation
                const endpoint = `${window.config.supabaseUrl}/rest/v1/ratings?id=eq.${userId}&select=rating_0_10,date,event_type&order=date.asc`;
                console.log("Fetching ratings from endpoint:", endpoint);
                
                const headers = {
                    'Content-Type': 'application/json',
                    'apikey': window.config.supabaseKey,
                    'Authorization': `Bearer ${accessToken}`
                };
                
                console.log("Using headers:", JSON.stringify({
                    'Content-Type': headers['Content-Type'],
                    'apikey': headers.apikey ? "Present" : "Missing",
                    'Authorization': headers.Authorization ? "Present" : "Missing"
                }));
                
                const response = await fetch(endpoint, {
                    method: 'GET',
                    headers: headers
                });
                
                console.log("Rating data response status:", response.status);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error("Error response:", errorText);
                    throw new Error(`Failed to fetch rating data: ${response.status} - ${errorText}`);
                }
                
                const data = await response.json();
                console.log('Rating history data retrieved:', data.length, 'records');
                console.log('First few records:', data.slice(0, 3));
                
                // Process the data exactly like the Swift implementation
                ratingTrendData = data.map(item => {
                    return {
                        date: new Date(item.date),
                        rating: item.rating_0_10,
                        eventType: item.event_type || 'match'
                    };
                });
                
                console.log('Processed rating data:', ratingTrendData.length, 'records');
                
                // Restore chart container and update chart
                chartContainer.innerHTML = '<canvas id="ratingChart"></canvas>';
                
                if (ratingTrendData.length === 0) {
                    console.log('No rating data available for this user');
                    chartContainer.innerHTML = 
                        '<div class="d-flex flex-column justify-content-center align-items-center h-100">' +
                        '<i class="fas fa-chart-line mb-3" style="font-size: 48px; color: #ccc;"></i>' +
                        '<p class="text-center text-muted">No rating data available yet. Play matches to see your rating trend!</p>' +
                        '</div>';
                    
                    // Reset stats
                    updateRatingStats([]);
                    return;
                }
                
                updateRatingChart(ratingTrendData);
                
            } catch (error) {
                console.error('Error loading rating trend data:', error);
                document.getElementById('ratingChart').parentElement.innerHTML = 
                    `<div class="alert alert-danger">Error loading rating data: ${error.message}</div>`;
                
                // Reset stats
                updateRatingStats([]);
            }
        }

        // Update rating chart with data
        function updateRatingChart(data) {
            // Filter data based on selected time range
            const filteredData = filterDataByTimeRange(data);
            
            // Calculate statistics
            updateRatingStats(filteredData);
            
            // Create or update the chart
            createRatingChart(filteredData);
        }

        // Filter data by selected time range
        function filterDataByTimeRange(data) {
            if (!data || data.length === 0) {
                return [];
            }
            
            const timeRange = document.getElementById('timeRangeSelector').value;
            const now = new Date();
            let cutoffDate = new Date(0); // distant past as default
            
            switch (timeRange) {
                case 'week':
                    cutoffDate = new Date(now);
                    cutoffDate.setDate(cutoffDate.getDate() - 7);
                    break;
                case 'month':
                    cutoffDate = new Date(now);
                    cutoffDate.setMonth(cutoffDate.getMonth() - 1);
                    break;
                case 'threeMonths':
                    cutoffDate = new Date(now);
                    cutoffDate.setMonth(cutoffDate.getMonth() - 3);
                    break;
                case 'sixMonths':
                    cutoffDate = new Date(now);
                    cutoffDate.setMonth(cutoffDate.getMonth() - 6);
                    break;
                case 'year':
                    cutoffDate = new Date(now);
                    cutoffDate.setFullYear(cutoffDate.getFullYear() - 1);
                    break;
                case 'all':
                    // Use distant past (default)
                    break;
            }
            
            return data.filter(item => item.date >= cutoffDate);
        }

        // Calculate and update rating statistics
        function updateRatingStats(data) {
            if (!data || data.length === 0) {
                // No data, set defaults
                document.getElementById('highestRating').textContent = '—';
                document.getElementById('lowestRating').textContent = '—';
                document.getElementById('averageRating').textContent = '—';
                document.getElementById('matchesCount').textContent = '0';
                return;
            }
            
            // Calculate highest, lowest, and average
            const ratings = data.map(item => item.rating);
            const highest = Math.max(...ratings);
            const lowest = Math.min(...ratings);
            const average = ratings.reduce((sum, rating) => sum + rating, 0) / ratings.length;
            
            // Count matches (not coach ratings)
            const matchesCount = data.filter(item => item.eventType === 'match').length;
            
            // Update the UI
            document.getElementById('highestRating').textContent = highest.toFixed(1);
            document.getElementById('lowestRating').textContent = lowest.toFixed(1);
            document.getElementById('averageRating').textContent = average.toFixed(1);
            document.getElementById('matchesCount').textContent = matchesCount.toString();
        }

        // Create or update the rating trend chart
        function createRatingChart(data) {
            const chartElement = document.getElementById('ratingChart');
            
            if (!data || data.length === 0) {
                // No data, show message on chart
                if (ratingChart) {
                    ratingChart.destroy();
                    ratingChart = null;
                }
                
                chartElement.parentElement.innerHTML = 
                    '<div class="d-flex flex-column justify-content-center align-items-center h-100">' +
                    '<i class="fas fa-chart-line mb-3" style="font-size: 48px; color: #ccc;"></i>' +
                    '<p class="text-center text-muted">No rating data available. Play matches to see your rating trend!</p>' +
                    '</div>';
                return;
            }
            
            // Get the gold color from CSS variables
            const goldColor = getComputedStyle(document.documentElement).getPropertyValue('--gold').trim() || '#d4af37';
            const secondaryColor = getComputedStyle(document.documentElement).getPropertyValue('--dark-blue').trim() || '#1a2238';
            
            // Sort data by date to ensure proper line connection
            data.sort((a, b) => a.date - b.date);
            
            // Create a single dataset for the line with all points
            const datasets = [
                {
                    label: 'Rating Trend',
                    data: data.map(item => ({
                        x: item.date,
                        y: item.rating,
                        eventType: item.eventType
                    })),
                    borderColor: goldColor, // changed from secondaryColor to goldColor
                    backgroundColor: 'rgba(212, 175, 55, 0.1)', // subtle gold fill
                    fill: false,
                    tension: 0.3,
                    pointRadius: (context) => {
                        const dataPoint = context.dataset.data[context.dataIndex];
                        return dataPoint.eventType === 'coach' ? 8 : 5;
                    },
                    pointStyle: (context) => {
                        const dataPoint = context.dataset.data[context.dataIndex];
                        return dataPoint.eventType === 'coach' ? 'rectRot' : 'circle';
                    },
                    pointBackgroundColor: (context) => {
                        const dataPoint = context.dataset.data[context.dataIndex];
                        return dataPoint.eventType === 'coach' ? 'red' : goldColor;
                    },
                    pointBorderColor: (context) => {
                        const dataPoint = context.dataset.data[context.dataIndex];
                        return dataPoint.eventType === 'coach' ? 'red' : goldColor;
                    }
                }
            ];
            
            // Calculate y-axis range
            const ratings = data.map(item => item.rating);
            const min = Math.max(0, Math.min(...ratings) - 0.5);
            const max = Math.min(10, Math.max(...ratings) + 0.5);
            
            // Destroy existing chart if it exists
            if (ratingChart) {
                ratingChart.destroy();
            }
            
            // Create new chart
            ratingChart = new Chart(chartElement, {
                type: 'line',
                data: {
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: data.length > 20 ? 'month' : 'day',
                                displayFormats: {
                                    day: 'MMM d',
                                    month: 'MMM yyyy'
                                }
                            },
                            title: {
                                display: true,
                                text: 'Date'
                            }
                        },
                        y: {
                            min: min,
                            max: max,
                            title: {
                                display: true,
                                text: 'Rating'
                            },
                            ticks: {
                                stepSize: 0.5
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false // We have our custom legend
                        },
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    const date = new Date(context[0].parsed.x);
                                    return date.toLocaleDateString();
                                },
                                label: function(context) {
                                    const dataPoint = context.dataset.data[context.dataIndex];
                                    const ratingType = dataPoint.eventType === 'coach' ? 'Coach Rating' : 'Match Rating';
                                    return `${ratingType}: ${context.parsed.y.toFixed(1)}`;
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // Save user name
        async function saveUserName(userId, newName) {
            try {
                console.log(`Updating display name to: ${newName} for user: ${userId}`);
                
                // Get current session - same way as RatingTrendView.swift
                const { data: { session } } = await supabase.auth.getSession();
                if (!session) {
                    throw new Error('No active session found');
                }
                
                const accessToken = session.access_token;
                console.log("Got access token:", accessToken ? "Valid token" : "No token");
                
                // Create the update URL - matching Swift app implementation
                const url = `${window.config.supabaseUrl}/rest/v1/user_profiles?id=eq.${userId}`;
                
                // Set up headers
                const headers = {
                    'Content-Type': 'application/json',
                    'apikey': window.config.supabaseKey,
                    'Authorization': `Bearer ${accessToken}`
                };
                
                // Create the update body with display_name
                const updateData = {
                    display_name: newName
                };
                
                // Make the PATCH request
                const response = await fetch(url, {
                    method: 'PATCH',
                    headers: headers,
                    body: JSON.stringify(updateData)
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Failed to update name: HTTP ${response.status} - ${errorText}`);
                }
                
                // Update local storage to match Swift app behavior
                localStorage.setItem('currentUserFullName', newName);
                
                // Update welcome message live
                document.getElementById('userName').textContent = newName;
                
                alert('Your name has been updated successfully.');
            } catch (error) {
                console.error('Error saving user name:', error);
                alert('Failed to update your name. Please try again.');
            }
        }
        
        // Delete user account
        async function deleteUserAccount(userId) {
            try {
                // Show loading overlay
                const loadingOverlay = document.createElement('div');
                loadingOverlay.classList.add('position-fixed', 'top-0', 'start-0', 'w-100', 'h-100', 'd-flex', 'justify-content-center', 'align-items-center');
                loadingOverlay.style.backgroundColor = 'rgba(0,0,0,0.5)';
                loadingOverlay.style.zIndex = '9999';
                loadingOverlay.innerHTML = `
                    <div class="bg-white p-4 rounded shadow-lg text-center">
                        <div class="spinner-border text-primary mb-3" role="status"></div>
                        <p class="mb-0">Deleting your account...</p>
                    </div>
                `;
                document.body.appendChild(loadingOverlay);
                
                // TODO: Implement actual account deletion logic
                // This would involve deleting data from multiple tables
                
                // For demo purposes, just sign out
                setTimeout(async () => {
                    try {
                        const { error } = await supabase.auth.signOut();
                        if (error) throw error;
                        window.location.href = '/auth.html';
                    } catch (error) {
                        console.error('Error during sign out:', error);
                        document.body.removeChild(loadingOverlay);
                        alert('An error occurred during account deletion. Please try again.');
                    }
                }, 2000);
                
            } catch (error) {
                console.error('Error deleting account:', error);
                alert('Failed to delete your account. Please try again.');
            }
        }
        
        // Refresh user profile
        async function refreshUserProfile(userId) {
            const refreshBtn = document.getElementById('refreshRatingBtn');
            const originalHTML = refreshBtn.innerHTML;
            
            try {
                refreshBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>';
                refreshBtn.disabled = true;
                
                console.log("Forcing profile refresh for user ID:", userId);
                
                // Get current session - same way as RatingTrendView.swift
                const { data: { session } } = await supabase.auth.getSession();
                if (!session) {
                    throw new Error('No active session found');
                }
                
                const accessToken = session.access_token;
                console.log("Got access token:", accessToken ? "Valid token" : "No token");
                
                // Clear any local cache first - matching Swift app behavior
                localStorage.removeItem('profileCache_' + userId);
                
                // Re-fetch profile data using the same endpoint pattern as Swift app
                const headers = {
                    'Content-Type': 'application/json',
                    'apikey': window.config.supabaseKey,
                    'Authorization': `Bearer ${accessToken}`
                };
                
                // Create the combined profile endpoint that includes clubs and ratings
                const profileEndpoint = `${window.config.supabaseUrl}/rest/v1/user_profiles?id=eq.${userId}&select=*,clubs(*),ratings_coach(*)`;
                console.log("Refreshing profile from endpoint:", profileEndpoint);
                
                const response = await fetch(profileEndpoint, {
                    method: 'GET',
                    headers: headers,
                    cache: 'no-store' // Force fresh data
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Profile refresh failed: ${response.status} - ${errorText}`);
                }
                
                const profileData = await response.json();
                console.log("Refreshed profile data:", profileData.length > 0 ? "Successfully retrieved" : "No data found");
                
                if (profileData && profileData.length > 0) {
                    const profile = profileData[0];
                    
                    // Update name if available
                    if (profile.display_name) {
                        document.getElementById('playerName').value = profile.display_name;
                        document.getElementById('userName').textContent = profile.display_name;
                    } else if (profile.full_name) {
                        document.getElementById('playerName').value = profile.full_name;
                        document.getElementById('userName').textContent = profile.full_name;
                    } else if (session.user && session.user.email) {
                        const formatted = formatUserName(session.user.email);
                        document.getElementById('playerName').value = formatted;
                        document.getElementById('userName').textContent = formatted;
                    } else {
                        document.getElementById('playerName').value = 'User';
                        document.getElementById('userName').textContent = 'User';
                    }
                    
                    // Get ratings data
                    const ratings = profile.ratings_coach;
                    if (ratings && ratings.length > 0) {
                        // Sort ratings by date in descending order
                        const sortedRatings = ratings.sort((a, b) => {
                            return new Date(b.date) - new Date(a.date);
                        });
                        
                        const latestRating = sortedRatings[0];
                        
                        // Update player rating
                        if (latestRating.rating) {
                            document.getElementById('playerRating').textContent = latestRating.rating.toFixed(1);
                        }
                        
                        // Update category
                        if (latestRating.category) {
                            document.getElementById('playerCategory').textContent = latestRating.category;
                        }
                        
                        // Update assessment date
                        if (latestRating.date) {
                            const assessmentDate = new Date(latestRating.date);
                            document.getElementById('assessmentDate').textContent = assessmentDate.toLocaleDateString();
                        }
                        
                        // Update coach name
                        if (latestRating.coach_name || latestRating.assessor) {
                            document.getElementById('assessedBy').textContent = latestRating.coach_name || latestRating.assessor;
                        }
                    }
                }
                
                // Also refresh match ratings
                const ratingsEndpoint = `${window.config.supabaseUrl}/rest/v1/ratings?id=eq.${userId}&select=rating_0_10,confidence_pct,date&order=date.desc&limit=1`;
                console.log("Refreshing match ratings from:", ratingsEndpoint);
                
                const ratingsResponse = await fetch(ratingsEndpoint, {
                    method: 'GET',
                    headers: headers,
                    cache: 'no-store' // Force fresh data
                });
                
                if (ratingsResponse.ok) {
                    const matchRatings = await ratingsResponse.json();
                    console.log("Match ratings response:", matchRatings.length > 0 ? "Data found" : "No data found");
                    
                    if (matchRatings && matchRatings.length > 0) {
                        const latestMatchRating = matchRatings[0];
                        
                        if (latestMatchRating.rating_0_10) {
                            document.getElementById('matchRating').textContent = latestMatchRating.rating_0_10.toFixed(1);
                        }
                        
                        if (latestMatchRating.confidence_pct) {
                            document.getElementById('ratingConfidence').textContent = 
                                (latestMatchRating.confidence_pct * 100).toFixed(1) + '%';
                        }
                    }
                } else {
                    console.warn("Failed to refresh match ratings:", await ratingsResponse.text());
                }
                
                // Also refresh the rating trend chart if it's visible
                const chartContainer = document.getElementById('ratingTrendContainer');
                if (chartContainer.style.display !== 'none') {
                    console.log("Refreshing rating trend chart");
                    loadRatingTrendData(userId, false); // false = force refresh from server
                }
                
                alert('Profile data refreshed successfully.');
            } catch (error) {
                console.error('Error refreshing profile:', error);
                alert('Failed to refresh profile data. Please try again.');
            } finally {
                refreshBtn.innerHTML = originalHTML;
                refreshBtn.disabled = false;
            }
        }

        
        // Function to test Supabase connection
        async function testSupabaseConnection(session) {
            try {
                // Log authentication info to console instead of displaying in UI
                console.log('Authentication Status: Authenticated');
                console.log('User ID:', session.user.id);
                console.log('Provider:', session.user.app_metadata.provider || 'Unknown');
                
                // Still run the database test silently
                try {
                    // Try to query a random table to verify permissions work
                    const { count, error: countError } = await supabase
                        .from('profiles')
                        .select('*', { count: 'exact', head: true });
                        
                    if (countError) {
                        console.log('Database Access: Failed -', countError.message);
                        console.warn('Note: Your account may have limited database access. Some features may not be available.');
                    } else {
                        console.log('Database Access: Success - Found', count, 'profiles');
                    }

                } catch (dbError) {
                    console.error('Database Access Failed:', dbError.message);
                }

            } catch (error) {
                console.error('Connection Test Failed:', error.message);
            }

        }

        
        // Check if the user is authenticated
        async function checkAuthentication() {
            let redirectAttempted = false;
            
            try {
                const { data: { session }, error } = await supabase.auth.getSession();
                
                if (error) {
                    console.error('Error checking session:', error);
                    // Log to console but don't show in UI
                    addDebugInfo(`Session error: ${error.message}`);
                    
                    // Wait to display the redirect message
                    setTimeout(() => {
                        if (!redirectAttempted) {
                            redirectAttempted = true;
                            localStorage.setItem('authRedirectTime', Date.now().toString());
                            window.location.href = '/auth.html';
                        }

                    }, 2000);
                    return;
                }

                
                if (!session) {
                    // Log to console but don't show in UI
                    addDebugInfo('No active session found');
                    
                    // Wait to redirect
                    setTimeout(() => {
                        if (!redirectAttempted) {
                            redirectAttempted = true;
                            localStorage.setItem('authRedirectTime', Date.now().toString());
                            window.location.href = '/auth.html';
                        }

                    }, 2000);
                    return;
                }

                
                // Log to console but don't show in UI
                addDebugInfo(`Session found for user: ${session.user.id}`);
                
                try {
                    // Try to get the user profile
                    const { data: profile, error: profileError } = await supabase
                        .from('profiles')
                        .select('*')
                        .eq('id', session.user.id)
                        .single();
                    
                    if (profileError) {
                        // Log to console but don't show in UI
                        addDebugInfo(`Profile fetch error: ${profileError.message}`);
                        
                        // Even if profile fetch fails, show a basic dashboard with a friendly name
                        const userEmail = session.user.email || 'User';
                        const displayName = formatUserName(userEmail);
                        document.getElementById('userName').textContent = displayName;
                    } else {
                        // Log available profile fields for debugging
                        addDebugInfo(`Profile data: display_name=${profile.display_name}, full_name=${profile.full_name}`);
                        
                        // Update UI with user data - prioritize display_name, then full_name, then friendly email format
                        const displayName = profile.display_name || profile.full_name || formatUserName(session.user.email) || 'User';
                        document.getElementById('userName').textContent = displayName;
                        
                        // Log which field was used
                        if (profile.display_name) {
                            console.log('Using display_name for user:', profile.display_name);
                        } else if (profile.full_name) {
                            console.log('Using full_name for user:', profile.full_name);
                        } else {
                            console.log('Using formatted email for user:', formatUserName(session.user.email));
                        }

                        
                        // Log to console but don't show in UI
                        addDebugInfo('Profile data loaded successfully');
                        
                        // Check if user is admin
                        const isAdmin = profile.is_admin === true;
                        addDebugInfo(`User is admin: ${isAdmin}`);
                        
                        // Store admin status for later use
                        window.userIsAdmin = isAdmin;
                    }

                    
                    // Load box league data
                    await loadBoxLeagueData(session.user.id);
                    
                    // We got this far, so authentication works
                    showBasicDashboard(session);
                    
                } catch (dataError) {
                    // Log to console but don't show in UI
                    addDebugInfo(`Data loading error: ${dataError.message}`);
                    
                    // If we fail to get profile but have a session, still show a basic dashboard
                    showBasicDashboard(session);
                }

            } catch (error) {
                console.error('Error checking authentication:', error);
                // Log to console but don't show in UI
                addDebugInfo(`Authentication error: ${error.message}`);
                
                // Wait to redirect
                setTimeout(() => {
                    if (!redirectAttempted) {
                        redirectAttempted = true;
                        localStorage.setItem('authRedirectTime', Date.now().toString());
                        window.location.href = '/auth.html';
                    }

                }, 2000);
            }

        }

        // Custom date range selector functionality
        document.addEventListener('DOMContentLoaded', function() {
            // Ensure this only runs once the DOM is loaded
            const toggleCustomDateBtn = document.getElementById('toggleCustomDateBtn');
            const customDateSelector = document.getElementById('customDateSelector');
            const startDatePicker = document.getElementById('startDatePicker');
            const endDatePicker = document.getElementById('endDatePicker');
            const applyCustomDateBtn = document.getElementById('applyCustomDateBtn');
            const dateRangeFilter = document.getElementById('matchDateRangeFilter');
            
            if (toggleCustomDateBtn) {
                // Set default dates - start date 30 days ago, end date today
                const today = new Date();
                const thirtyDaysAgo = new Date();
                thirtyDaysAgo.setDate(today.getDate() - 30);
                
                // Format dates as YYYY-MM-DD for date inputs
                startDatePicker.value = formatDateForInput(thirtyDaysAgo);
                endDatePicker.value = formatDateForInput(today);
                
                // Toggle custom date selector visibility
                toggleCustomDateBtn.addEventListener('click', function() {
                    customDateSelector.style.display = customDateSelector.style.display === 'none' ? 'block' : 'none';
                    
                    // Toggle active class on button
                    this.classList.toggle('active');
                    
                    // If hiding, reset to selected dropdown value
                    if (customDateSelector.style.display === 'none') {
                        dateRangeFilter.disabled = false;
                        filterMatches();
                    } else {
                        // If showing, disable the dropdown
                        dateRangeFilter.disabled = true;
                    }
                });
                
                // Apply custom date range
                applyCustomDateBtn.addEventListener('click', function() {
                    const startDate = new Date(startDatePicker.value);
                    const endDate = new Date(endDatePicker.value);
                    
                    // Validate date range
                    if (startDate > endDate) {
                        alert('Start date must be before end date');
                        return;
                    }
                    
                    // Apply custom filter
                    filterMatchesByCustomDateRange(startDate, endDate);
                });
            }
            
            // Helper function to format date as YYYY-MM-DD
            function formatDateForInput(date) {
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            }
        });
        
        // Function to filter matches by custom date range
        async function filterMatchesByCustomDateRange(startDate, endDate) {
            try {
                console.log(`Filtering matches between ${startDate.toISOString()} and ${endDate.toISOString()}`);
                
                // Set end date to end of day
                endDate.setHours(23, 59, 59, 999);
                
                // Get filter values
                const filterType = document.getElementById('matchHistoryFilter').value;
                const searchText = document.getElementById('matchSearchInput').value.toLowerCase();
                
                // Get current user ID from the authenticated session using more reliable method
                const auth = await supabase.auth.getSession();
                if (!auth.data?.session?.user) {
                    console.warn("No authenticated user found for custom date filtering");
                    throw new Error("Authentication required to filter matches");
                }
                
                const currentUserId = auth.data.session.user.id.toLowerCase();
                const userClubId = userProfile?.clubs?.id;
                
                console.log("Current user ID for custom date filtering:", currentUserId);
                
                // Start with all matches
                let filteredMatches = [...allMatches];
                
                // First, filter out private matches that the user is not part of
                if (currentUserId) {
                    filteredMatches = filteredMatches.filter(match => {
                        // If it's not a private match, keep it
                        if (match.matchType !== 'private') {
                            return true;
                        }
                        
                        // If it's a private match, check if the user is a participant
                        const inTeam1 = match.team1.playerIds && match.team1.playerIds.some(id => 
                            id && id.toLowerCase() === currentUserId
                        );
                        
                        const inTeam2 = match.team2.playerIds && match.team2.playerIds.some(id => 
                            id && id.toLowerCase() === currentUserId
                        );
                        
                        // Only keep private matches where the user is participating
                        return inTeam1 || inTeam2;
                    });
                }
                
                // Apply user/club filter
                if (filterType === 'my' && currentUserId) {
                    console.log("Filtering by user ID:", currentUserId);
                    filteredMatches = filteredMatches.filter(match => {
                        // Check if user is in team1
                        const inTeam1 = match.team1.playerIds && match.team1.playerIds.some(id => 
                            id && id.toLowerCase() === currentUserId
                        );
                        
                        // Check if user is in team2
                        const inTeam2 = match.team2.playerIds && match.team2.playerIds.some(id => 
                            id && id.toLowerCase() === currentUserId
                        );
                        
                        return inTeam1 || inTeam2;
                    });
                } else if (filterType === 'club' && userClubId) {
                    console.log("Filtering by club ID:", userClubId);
                    filteredMatches = filteredMatches.filter(match => 
                        match.clubId === userClubId
                    );
                }
                
                // Apply custom date range filter
                filteredMatches = filteredMatches.filter(match => 
                    match.playedDate >= startDate && match.playedDate <= endDate
                );
                
                // Filter by search text
                if (searchText) {
                    console.log("Filtering by search text:", searchText);
                    filteredMatches = filteredMatches.filter(match => {
                        // Check if any player name contains the search text
                        const team1Players = match.team1.players.join(' ').toLowerCase();
                        const team2Players = match.team2.players.join(' ').toLowerCase();
                        
                        return team1Players.includes(searchText) || team2Players.includes(searchText);
                    });
                }
                
                // Filter to only show completed matches where there is a clear winner
                filteredMatches = filteredMatches.filter(match => 
                    match.status === 'completed' && match.team1.setsWon !== match.team2.setsWon
                );
                
                // Sort by date (newest first)
                filteredMatches.sort((a, b) => b.playedDate - a.playedDate);
                
                console.log(`Final filtered matches count (custom date range): ${filteredMatches.length}`);
                
                // Update the UI with filtered matches
                await renderMatchHistory(filteredMatches);
                
            } catch (error) {
                console.error("Error filtering by custom date range:", error);
                showMatchHistoryError("Error filtering by date range: " + error.message);
            }
        }
    </script>
    
    <!-- JavaScript for Match History -->
    <script>
        // Store match data globally for filtering
        let allMatches = [];
        let userProfile = null;
        
        // Function to initialize match history
        async function initializeMatchHistory() {
            try {
                console.log("Initializing match history");
                
                // First check if authentication is ready
                const { data, error } = await supabase.auth.getSession();
                if (error || !data.session) {
                    console.warn("Authentication not ready yet:", error?.message || "No session found");
                    
                    // Show message that we're waiting for authentication
                    document.getElementById('matchesLoading').innerHTML = `
                        <div class="d-flex flex-column align-items-center py-3">
                            <div class="spinner-border text-primary mb-2" role="status"></div>
                            <p>Waiting for authentication...</p>
                            <p class="text-muted small">Please wait a moment or refresh the page if this persists.</p>
                        </div>
                    `;
                    
                    // Try again in 1 second
                    setTimeout(() => {
                        initializeMatchHistory();
                    }, 1000);
                    return;
                }
                
                // Set up event listeners for filters
                document.getElementById('matchHistoryFilter').addEventListener('change', () => filterMatches());
                document.getElementById('matchDateRangeFilter').addEventListener('change', () => filterMatches());
                document.getElementById('matchSearchInput').addEventListener('input', () => filterMatches());
                
                // Ensure "My Matches" is selected by default
                document.getElementById('matchHistoryFilter').value = 'my';
                
                // Load match history data
                await loadMatchHistory();
            } catch (error) {
                console.error("Error initializing match history:", error);
                showMatchHistoryError("Failed to initialize match history: " + error.message);
            }
        }
        
        // Function to filter matches based on selected criteria
        async function filterMatches() {
            try {
                console.log("Filtering matches with current criteria");
                
                // Get filter values
                const filterType = document.getElementById('matchHistoryFilter').value;
                const dateRangeFilter = document.getElementById('matchDateRangeFilter').value;
                const searchText = document.getElementById('matchSearchInput').value.toLowerCase();
                
                console.log("Filter type:", filterType, "Date range:", dateRangeFilter);
                
                // Get current user ID and club ID from the authenticated session
                const auth = await supabase.auth.getSession();
                if (!auth.data?.session?.user) {
                    console.warn("No authenticated user found for filtering");
                    throw new Error("Authentication required to filter matches");
                }
                
                const currentUserId = auth.data.session.user.id.toLowerCase();
                const userClubId = userProfile?.clubs?.id;
                
                console.log("Current user ID for filtering:", currentUserId);
                
                // Start with all matches
                let filteredMatches = [...allMatches];
                
                // First, filter out private matches that the user is not part of (regardless of filter type)
                // This ensures private matches are only visible to participants
                if (currentUserId) {
                    filteredMatches = filteredMatches.filter(match => {
                        // If it's not a private match, keep it
                        if (match.matchType !== 'private') {
                            return true;
                        }
                        
                        // If it's a private match, check if the user is a participant
                        const inTeam1 = match.team1.playerIds && match.team1.playerIds.some(id => 
                            id && id.toLowerCase() === currentUserId
                        );
                        
                        const inTeam2 = match.team2.playerIds && match.team2.playerIds.some(id => 
                            id && id.toLowerCase() === currentUserId
                        );
                        
                        // Only keep private matches where the user is participating
                        return inTeam1 || inTeam2;
                    });
                    
                    console.log(`After private match privacy filtering: ${filteredMatches.length} matches remain`);
                }
                
                // Now apply the regular filters
                // Filter by owner/user
                if (filterType === 'my' && currentUserId) {
                    console.log("Filtering by user ID:", currentUserId);
                    filteredMatches = filteredMatches.filter(match => {
                        // Check if user is in team1
                        const inTeam1 = match.team1.playerIds && match.team1.playerIds.some(id => 
                            id && id.toLowerCase() === currentUserId
                        );
                        
                        // Check if user is in team2
                        const inTeam2 = match.team2.playerIds && match.team2.playerIds.some(id => 
                            id && id.toLowerCase() === currentUserId
                        );
                        
                        const isUserMatch = inTeam1 || inTeam2;
                        console.log(`Match ${match.id}: User in Team1: ${inTeam1}, User in Team2: ${inTeam2}, Is User Match: ${isUserMatch}`);
                        return isUserMatch;
                    });
                    
                    console.log(`After user filtering: ${filteredMatches.length} matches remain`);
                } else if (filterType === 'club' && userClubId) {
                    console.log("Filtering by club ID:", userClubId);
                    filteredMatches = filteredMatches.filter(match => 
                        match.clubId === userClubId
                    );
                }
                
                // Filter by date range
                if (dateRangeFilter !== 'all') {
                    const daysToLookBack = parseInt(dateRangeFilter);
                    const cutoffDate = new Date();
                    cutoffDate.setDate(cutoffDate.getDate() - daysToLookBack);
                    
                    console.log(`Filtering matches played after ${cutoffDate.toISOString()}`);
                    
                    filteredMatches = filteredMatches.filter(match => 
                        match.playedDate >= cutoffDate
                    );
                }
                
                // Filter by search text
                if (searchText) {
                    console.log("Filtering by search text:", searchText);
                    filteredMatches = filteredMatches.filter(match => {
                        // Check if any player name contains the search text
                        const team1Players = match.team1.players.join(' ').toLowerCase();
                        const team2Players = match.team2.players.join(' ').toLowerCase();
                        
                        return team1Players.includes(searchText) || team2Players.includes(searchText);
                    });
                }
                
                // Filter to only show completed matches where there is a clear winner
                filteredMatches = filteredMatches.filter(match => 
                    match.status === 'completed' && match.team1.setsWon !== match.team2.setsWon
                );
                
                // Sort by date (newest first)
                filteredMatches.sort((a, b) => b.playedDate - a.playedDate);
                
                console.log(`Final filtered matches count: ${filteredMatches.length}`);
                
                // Update the UI with filtered matches
                await renderMatchHistory(filteredMatches);
            } catch (error) {
                console.error("Error filtering matches:", error);
                showMatchHistoryError("Error filtering matches: " + error.message);
            }
        }
        
        // Function to load match history from Supabase
        async function loadMatchHistory() {
            try {
                // Show loading indicator
                document.getElementById('matchesLoading').style.display = 'block';
                document.getElementById('matchesEmpty').style.display = 'none';
                document.getElementById('matchesList').style.display = 'none';
                
                // Get session and access token
                const { data: { session } } = await supabase.auth.getSession();
                if (!session) {
                    throw new Error('No active session found');
                }
                
                const userId = session.user.id;
                console.log("Loading match history for user ID:", userId);
                
                // First get the user's profile to have access to their club ID
                try {
                    // Create the combined profile endpoint that includes clubs and ratings
                    const profileEndpoint = `${window.config.supabaseUrl}/rest/v1/user_profiles?id=eq.${userId}&select=*,clubs(*)`;
                    
                    // Set up headers for the request
                    const headers = {
                        'Content-Type': 'application/json',
                        'apikey': window.config.supabaseKey,
                        'Authorization': `Bearer ${session.access_token}`
                    };
                    
                    // Make the request
                    const response = await fetch(profileEndpoint, {
                        method: 'GET',
                        headers: headers
                    });
                    
                    if (!response.ok) {
                        throw new Error(`Profile fetch failed with status: ${response.status}`);
                    }
                    
                    const profileData = await response.json();
                    if (profileData && profileData.length > 0) {
                        userProfile = profileData[0];
                        console.log("User profile loaded:", userProfile);
                    }
                } catch (error) {
                    console.warn("Could not load user profile:", error);
                    // Continue anyway, we'll just not have the club filter available
                }
                
                // Query for matches
                // This query structure is similar to the one in the iOS app
                // First we'll get all matches (both completed and pending)
                const { data: matches, error } = await supabase
                    .from('padel_matches_view')
                    .select(`
                        id,
                        team1_players,
                        team2_players,
                        team1_player_ids,
                        team2_player_ids,
                        match_date,
                        team1_set_scores,
                        team2_set_scores,
                        team1_score,
                        team2_score,
                        location_id,
                        match_type,
                        match_status,
                        match_category,
                        submission_date,
                        submitter_id
                    `)
                    .order('match_date', { ascending: false });
                
                if (error) {
                    throw error;
                }
                
                console.log(`Loaded ${matches.length} matches from Supabase view`);
                
                // Process the matches to be in a similar format to the iOS app
                allMatches = matches.map(match => {
                    const playedDate = new Date(match.match_date);
                    
                    // Parse comma-separated strings back into arrays
                    const team1Players = match.team1_players ? match.team1_players.split(',').map(p => p.trim()) : [];
                    const team2Players = match.team2_players ? match.team2_players.split(',').map(p => p.trim()) : [];
                    const team1PlayerIds = match.team1_player_ids ? match.team1_player_ids.split(',').map(id => id.trim()) : [];
                    const team2PlayerIds = match.team2_player_ids ? match.team2_player_ids.split(',').map(id => id.trim()) : [];
                    const team1SetScores = match.team1_set_scores ? match.team1_set_scores.split(',').map(Number) : [];
                    const team2SetScores = match.team2_set_scores ? match.team2_set_scores.split(',').map(Number) : [];
                    
                    return {
                        id: match.id,
                        playedDate: playedDate,
                        createdAt: new Date(match.submission_date),
                        team1: {
                            players: team1Players,
                            playerIds: team1PlayerIds,
                            setScores: team1SetScores,
                            setsWon: match.team1_score || 0
                        },
                        team2: {
                            players: team2Players,
                            playerIds: team2PlayerIds,
                            setScores: team2SetScores,
                            setsWon: match.team2_score || 0
                        },
                        status: match.match_status?.toLowerCase() === 'completed' ? 'completed' : 'pending',
                        matchType: match.match_type?.toLowerCase() || 'open',
                        submitterId: match.submitter_id,
                        clubId: match.location_id,
                        matchCategory: match.match_category || 'regular'
                    };
                });
                
                // Apply filters to matches - use the dropdown's value which should be "my" by default
                console.log("Applying initial filter based on dropdown selection:", document.getElementById('matchHistoryFilter').value);
                await filterMatches();
                
            } catch (error) {
                console.error("Error loading match history:", error);
                showMatchHistoryError("Failed to load matches: " + error.message);
            }
        }
        
        // Function to render match history to the UI
        async function renderMatchHistory(matches) {
            const matchesList = document.getElementById('matchesList');
            const matchesEmpty = document.getElementById('matchesEmpty');
            const matchesLoading = document.getElementById('matchesLoading');
            
            // Hide loading indicator
            matchesLoading.style.display = 'none';
            
            if (matches.length === 0) {
                // Show empty state
                matchesList.style.display = 'none';
                matchesEmpty.style.display = 'block';
                await updateMatchStatistics([]); // Update stats with empty array
                await updateRecentMatches([]); // Update recent matches with empty array
                return;
            }
            
            // Show matches list
            matchesList.style.display = 'block';
            matchesEmpty.style.display = 'none';
            
            // Clear previous content
            matchesList.innerHTML = '';
            
            // Render each match
            matches.forEach(match => {
                const matchCard = createMatchCard(match);
                matchesList.appendChild(matchCard);
            });
            
            // Update match statistics
            await updateMatchStatistics(matches);
            
            // Update recent matches
            await updateRecentMatches(matches);
        }
        
        // Function to create a match card element
        function createMatchCard(match) {
            const team1Won = match.team1.setsWon > match.team2.setsWon;
            const team2Won = match.team2.setsWon > match.team1.setsWon;
            
            // Create card container
            const card = document.createElement('div');
            card.className = 'match-history-card';
            card.setAttribute('data-match-id', match.id);
            
            // Format date
            const dateOptions = { 
                year: 'numeric', 
                month: 'short', 
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            };
            const formattedDate = match.playedDate.toLocaleDateString('en-US', dateOptions);
            
            // Create match header with date and category
            let matchTypeClass = '';
            let matchTypeName = '';
            
            if (match.matchCategory === 'BoxLeague') {
                matchTypeClass = 'match-type-boxleague';
                matchTypeName = 'Box League';
            } else {
                // Determine match type label and class
                switch (match.matchType) {
                    case 'private':
                        matchTypeClass = 'match-type-private';
                        matchTypeName = 'Private';
                        break;
                    case 'open':
                        matchTypeClass = 'match-type-open';
                        matchTypeName = 'Open';
                        break;
                    case 'competitive':
                        matchTypeClass = 'match-type-competitive';
                        matchTypeName = 'Competitive';
                        break;
                    default:
                        matchTypeClass = 'match-type-open';
                        matchTypeName = 'Open';
                }
            }
            
            // Create match date header
            card.innerHTML = `
                <div class="match-date">
                    <span>${formattedDate}</span>
                    <span class="match-category ${matchTypeClass}">${matchTypeName}</span>
                </div>
                <div class="match-teams">
                    <div class="team-row ${team1Won ? 'winning-team' : ''}">
                        <div class="team-players">${match.team1.players.join(' & ')}</div>
                        <div class="team-score">
                            ${createSetScoresHtml(match.team1.setScores)}
                        </div>
                    </div>
                    <div class="set-divider"></div>
                    <div class="team-row ${team2Won ? 'winning-team' : ''}">
                        <div class="team-players">${match.team2.players.join(' & ')}</div>
                        <div class="team-score">
                            ${createSetScoresHtml(match.team2.setScores)}
                        </div>
                    </div>
                </div>
            `;
            
            // Add click event to show match details
            card.addEventListener('click', () => {
                showMatchDetails(match);
            });
            
            return card;
        }
        
        // Helper function to create set scores HTML
        function createSetScoresHtml(setScores) {
            if (!setScores || !Array.isArray(setScores) || setScores.length === 0) {
                return '';
            }
            
            return setScores.map(score => `
                <span class="set-score">${score}</span>
            `).join('');
        }
        
        // Function to show match details
        function showMatchDetails(match) {
            console.log("Showing details for match:", match);
            
            // Get a reference to the modal
            const modal = new bootstrap.Modal(document.getElementById('matchDetailModal'));
            
            // Format date
            const dateOptions = { 
                year: 'numeric', 
                month: 'long', 
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            };
            const formattedDate = match.playedDate.toLocaleDateString('en-US', dateOptions);
            
            // Set match date
            document.getElementById('matchDetailDate').textContent = formattedDate;
            
            // Set match category/type
            const matchDetailCategory = document.getElementById('matchDetailCategory');
            if (match.matchCategory === 'BoxLeague') {
                matchDetailCategory.textContent = 'Box League';
                matchDetailCategory.className = 'match-category match-type-boxleague';
            } else {
                // Determine match type name and class
                let matchTypeClass = '';
                let matchTypeName = '';
                
                switch (match.matchType) {
                    case 'private':
                        matchTypeClass = 'match-type-private';
                        matchTypeName = 'Private';
                        break;
                    case 'open':
                        matchTypeClass = 'match-type-open';
                        matchTypeName = 'Open';
                        break;
                    case 'competitive':
                        matchTypeClass = 'match-type-competitive';
                        matchTypeName = 'Competitive';
                        break;
                    default:
                        matchTypeClass = 'match-type-open';
                        matchTypeName = 'Open';
                }
                
                matchDetailCategory.textContent = matchTypeName;
                matchDetailCategory.className = 'match-category ' + matchTypeClass;
            }
            
            // Set club info if available
            const clubElement = document.getElementById('matchDetailClub');
            if (match.clubId) {
                // Try to resolve club name (this would be better if we fetched club details)
                clubElement.innerHTML = '<i class="fas fa-map-marker-alt me-1"></i> Club details not available';
                clubElement.style.display = 'block';
                
                // In a real implementation, you'd fetch the club details from Supabase
                // based on the club ID and then populate this field
            } else {
                clubElement.style.display = 'none';
            }
            
            // Set team 1 info
            document.getElementById('matchDetailTeam1').textContent = match.team1.players.join(' & ');
            const team1Won = match.team1.setsWon > match.team2.setsWon;
            if (team1Won) {
                document.getElementById('matchDetailTeam1Row').classList.add('winning-score');
            } else {
                document.getElementById('matchDetailTeam1Row').classList.remove('winning-score');
            }
            
            // Set team 2 info
            document.getElementById('matchDetailTeam2').textContent = match.team2.players.join(' & ');
            const team2Won = match.team2.setsWon > match.team1.setsWon;
            if (team2Won) {
                document.getElementById('matchDetailTeam2Row').classList.add('winning-score');
            } else {
                document.getElementById('matchDetailTeam2Row').classList.remove('winning-score');
            }
            
            // Set set scores
            document.getElementById('matchDetailTeam1Score').textContent = match.team1.setsWon;
            document.getElementById('matchDetailTeam2Score').textContent = match.team2.setsWon;
            
            // Set header names for sets table
            const team1Short = getTeamShortName(match.team1.players);
            const team2Short = getTeamShortName(match.team2.players);
            document.getElementById('matchDetailSetTeam1Header').textContent = team1Short;
            document.getElementById('matchDetailSetTeam2Header').textContent = team2Short;
            
            // Create set details
            const setScoresTable = document.getElementById('matchDetailSetScores');
            setScoresTable.innerHTML = '';
            
            // We need both team's set scores to be available and have the same length
            if (match.team1.setScores && match.team2.setScores && 
                match.team1.setScores.length === match.team2.setScores.length) {
                
                // Create a row for each set
                for (let i = 0; i < match.team1.setScores.length; i++) {
                    const row = document.createElement('tr');
                    
                    // Set number
                    const setCell = document.createElement('td');
                    setCell.textContent = `Set ${i + 1}`;
                    row.appendChild(setCell);
                    
                    // Team 1 score
                    const team1Cell = document.createElement('td');
                    team1Cell.textContent = match.team1.setScores[i];
                    // Highlight the winning score
                    if (match.team1.setScores[i] > match.team2.setScores[i]) {
                        team1Cell.classList.add('winning-score');
                    }
                    row.appendChild(team1Cell);
                    
                    // Team 2 score
                    const team2Cell = document.createElement('td');
                    team2Cell.textContent = match.team2.setScores[i];
                    // Highlight the winning score
                    if (match.team2.setScores[i] > match.team1.setScores[i]) {
                        team2Cell.classList.add('winning-score');
                    }
                    row.appendChild(team2Cell);
                    
                    setScoresTable.appendChild(row);
                }
                
                // Show the sets section
                document.getElementById('matchDetailSets').style.display = 'block';
            } else {
                // Hide the sets section if no detailed set scores
                document.getElementById('matchDetailSets').style.display = 'none';
            }
            
            // Set submitter info
            const submitterElement = document.getElementById('matchDetailSubmitter');
            submitterElement.textContent = 'Submitted on ' + new Date(match.createdAt).toLocaleDateString('en-US', { 
                year: 'numeric', 
                month: 'short', 
                day: 'numeric'
            });
            
            // Show the modal
            modal.show();
        }
        
        // Helper function to get shortened team name
        function getTeamShortName(players) {
            if (!players || players.length === 0) {
                return "Team";
            }
            
            if (players.length === 1) {
                // If just one player, return first name
                const names = players[0].split(' ');
                return names[0];
            }
            
            // For doubles, use initials
            return players.map(player => {
                const names = player.split(' ');
                return names[0].charAt(0);
            }).join(' & ');
        }
        
        // Function to show error message
        function showMatchHistoryError(message) {
            const matchesList = document.getElementById('matchesList');
            const matchesEmpty = document.getElementById('matchesEmpty');
            const matchesLoading = document.getElementById('matchesLoading');
            
            // Hide loading indicator and empty state
            matchesLoading.style.display = 'none';
            matchesEmpty.style.display = 'none';
            
            // Show error in matches list
            matchesList.style.display = 'block';
            matchesList.innerHTML = `
                <div class="alert alert-danger">
                    <i class="fas fa-exclamation-circle me-2"></i>
                    ${message}
                </div>
            `;
        }
        
        // Add the initialization of match history when the dashboard content is shown
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize when the stats tab is shown
            const statsTab = document.getElementById('stats-tab');
            if (statsTab) {
                statsTab.addEventListener('shown.bs.tab', function() {
                    // Only initialize if not already loaded
                    if (allMatches.length === 0) {
                        initializeMatchHistory();
                    }
                });
            }
        });
        
        // Function to update match statistics based on filtered matches
        async function updateMatchStatistics(matches) {
            const statsContainer = document.getElementById('matchStats');
            
            try {
                // Get current user using supabase.auth.getSession() for better error handling
                const auth = await supabase.auth.getSession();
                if (!auth.data?.session?.user) {
                    console.warn("No authenticated user found for match statistics");
                    statsContainer.innerHTML = `
                        <p class="text-center py-3">Please sign in to view match statistics.</p>
                    `;
                    return;
                }
                
                const currentUserId = auth.data.session.user.id.toLowerCase();
                
                if (matches.length === 0) {
                    statsContainer.innerHTML = `
                        <p class="text-center py-3">No match statistics available yet.</p>
                    `;
                    return;
                }
                
                // Calculate statistics
                let totalMatches = 0;
                let wins = 0;
                let losses = 0;
                let totalSetsWon = 0;
                let totalSetsLost = 0;
                let highestWinStreak = 0;
                let currentWinStreak = 0;
                let recentResults = [];
                
                // Sort matches by date (newest first) to calculate streaks correctly
                const sortedMatches = [...matches].sort((a, b) => b.playedDate - a.playedDate);
                
                // Process each match to calculate stats
                sortedMatches.forEach(match => {
                    // Check if user participated in this match
                    const inTeam1 = match.team1.playerIds && match.team1.playerIds.some(id => 
                        id && id.toLowerCase() === currentUserId
                    );
                    
                    const inTeam2 = match.team2.playerIds && match.team2.playerIds.some(id => 
                        id && id.toLowerCase() === currentUserId
                    );
                    
                    if (!inTeam1 && !inTeam2) {
                        return; // User didn't participate in this match
                    }
                    
                    totalMatches++;
                    
                    // Determine if user won or lost
                    const userWon = (inTeam1 && match.team1.setsWon > match.team2.setsWon) || 
                                   (inTeam2 && match.team2.setsWon > match.team1.setsWon);
                    
                    if (userWon) {
                        wins++;
                        currentWinStreak++;
                        if (currentWinStreak > highestWinStreak) {
                            highestWinStreak = currentWinStreak;
                        }
                        recentResults.push('W');
                    } else {
                        losses++;
                        currentWinStreak = 0;
                        recentResults.push('L');
                    }
                    
                    // Calculate sets won/lost by the user
                    if (inTeam1) {
                        totalSetsWon += match.team1.setsWon;
                        totalSetsLost += match.team2.setsWon;
                    } else {
                        totalSetsWon += match.team2.setsWon;
                        totalSetsLost += match.team1.setsWon;
                    }
                    
                    // Keep only the 10 most recent results for display
                    if (recentResults.length > 10) {
                        recentResults = recentResults.slice(0, 10);
                    }
                });
                
                // Calculate win rate
                const winRate = totalMatches > 0 ? Math.round((wins / totalMatches) * 100) : 0;
                
                // Create statistics HTML
                statsContainer.innerHTML = `
                    <div class="row text-center g-2">
                        <div class="col-6 col-md-3">
                            <div class="border border-secondary rounded p-2">
                                <h5>${totalMatches}</h5>
                                <small>Matches</small>
                            </div>
                        </div>
                        <div class="col-6 col-md-3">
                            <div class="border border-secondary rounded p-2">
                                <h5>${wins} - ${losses}</h5>
                                <small>Record</small>
                            </div>
                        </div>
                        <div class="col-6 col-md-3">
                            <div class="border border-secondary rounded p-2">
                                <h5>${winRate}%</h5>
                                <small>Win Rate</small>
                            </div>
                        </div>
                        <div class="col-6 col-md-3">
                            <div class="border border-secondary rounded p-2">
                                <h5>${highestWinStreak}</h5>
                                <small>Best Run</small>
                            </div>
                        </div>
                    </div>
                    
                    <div class="mt-3">
                        <h6>Set Statistics</h6>
                        <div class="progress">
                            <div class="progress-bar bg-success" role="progressbar" 
                                style="width: ${totalSetsWon + totalSetsLost > 0 ? (totalSetsWon / (totalSetsWon + totalSetsLost) * 100) : 0}%" 
                                aria-valuenow="${totalSetsWon}" aria-valuemin="0" aria-valuemax="${totalSetsWon + totalSetsLost}">
                                ${totalSetsWon}
                            </div>
                            <div class="progress-bar bg-danger" role="progressbar" 
                                style="width: ${totalSetsWon + totalSetsLost > 0 ? (totalSetsLost / (totalSetsWon + totalSetsLost) * 100) : 0}%" 
                                aria-valuenow="${totalSetsLost}" aria-valuemin="0" aria-valuemax="${totalSetsWon + totalSetsLost}">
                                ${totalSetsLost}
                            </div>
                        </div>
                        <div class="d-flex justify-content-between mt-1">
                            <small class="text-muted">Sets Won</small>
                            <small class="text-muted">Sets Lost</small>
                        </div>
                    </div>
                    
                    <div class="mt-3">
                        <h6>Match Form</h6>
                        <div class="d-flex flex-wrap">
                            ${recentResults.map(result => `
                                <div class="me-2 mb-2 rounded-circle d-flex align-items-center justify-content-center" 
                                    style="width: 30px; height: 30px; background-color: ${result === 'W' ? 'rgba(40, 167, 69, 0.2)' : 'rgba(220, 53, 69, 0.2)'}; 
                                    color: ${result === 'W' ? '#28a745' : '#dc3545'}; font-weight: bold;">
                                    ${result}
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            } catch (error) {
                console.error('Error updating match statistics:', error);
                statsContainer.innerHTML = `
                    <p class="text-center py-3">Error loading match statistics: ${error.message}</p>
                `;
            }
        }
        
        // Function to update the recent matches section
        async function updateRecentMatches(matches) {
            const recentMatchesContainer = document.getElementById('recentMatches');
            
            try {
                // Get current user using supabase.auth.getSession() for better error handling
                const auth = await supabase.auth.getSession();
                if (!auth.data?.session?.user) {
                    console.warn("No authenticated user found for recent matches");
                    recentMatchesContainer.innerHTML = `
                        <p class="text-center py-3">Please sign in to view recent matches.</p>
                    `;
                    return;
                }
                
                const currentUserId = auth.data.session.user.id.toLowerCase();
                
                if (!matches || matches.length === 0) {
                    recentMatchesContainer.innerHTML = `
                        <p class="text-center py-3">No recent matches found.</p>
                    `;
                    return;
                }
                
                // Sort matches by date (newest first)
                const sortedMatches = [...matches].sort((a, b) => b.playedDate - a.playedDate);
                
                // Get matches where the user participated
                const userMatches = sortedMatches.filter(match => {
                    if (!currentUserId) return false;
                    
                    const inTeam1 = match.team1.playerIds && match.team1.playerIds.some(id => 
                        id && id.toLowerCase() === currentUserId
                    );
                    
                    const inTeam2 = match.team2.playerIds && match.team2.playerIds.some(id => 
                        id && id.toLowerCase() === currentUserId
                    );
                    
                    return inTeam1 || inTeam2;
                });
                
                // Take up to 5 most recent matches
                const recentMatches = userMatches.slice(0, 5);
                
                if (recentMatches.length === 0) {
                    recentMatchesContainer.innerHTML = `
                        <p class="text-center py-3">No recent matches found.</p>
                    `;
                    return;
                }
                
                // Generate HTML for recent matches
                let recentMatchesHTML = '';
                
                recentMatches.forEach(match => {
                    // Determine if user was in team 1 or 2
                    const inTeam1 = match.team1.playerIds && match.team1.playerIds.some(id => 
                        id && id.toLowerCase() === currentUserId
                    );
                    
                    // Determine if user won
                    const userWon = (inTeam1 && match.team1.setsWon > match.team2.setsWon) || 
                                   (!inTeam1 && match.team2.setsWon > match.team1.setsWon);
                    
                    // Format the date
                    const matchDate = new Date(match.playedDate);
                    const dateString = matchDate.toLocaleDateString('en-US', {
                        month: 'short',
                        day: 'numeric'
                    });
                    
                    // Get opponent name(s)
                    const opponentTeam = inTeam1 ? match.team2 : match.team1;
                    const opponentNames = opponentTeam.players.join(' & ');
                    
                    // Result text
                    const resultText = userWon ? "Won" : "Lost";
                    const resultClass = userWon ? "text-success" : "text-danger";
                    
                    recentMatchesHTML += `
                        <div class="d-flex align-items-center mb-2 p-2 rounded" style="background-color: rgba(255, 255, 255, 0.05);">
                            <div class="me-3 d-flex flex-column align-items-center">
                                <span class="badge ${userWon ? 'bg-success' : 'bg-danger'}">${resultText}</span>
                                <small class="text-muted">${dateString}</small>
                            </div>
                            <div class="flex-grow-1">
                                <small class="text-muted">vs</small>
                                <span class="ms-1">${opponentNames}</span>
                            </div>
                            <div class="text-end">
                                <span class="${resultClass} fw-bold">
                                    ${inTeam1 ? `${match.team1.setsWon}-${match.team2.setsWon}` : `${match.team2.setsWon}-${match.team1.setsWon}`}
                                </span>
                            </div>
                        </div>
                    `;
                });
                
                // Update container
                recentMatchesContainer.innerHTML = recentMatchesHTML;
            } catch (error) {
                console.error('Error updating recent matches:', error);
                recentMatchesContainer.innerHTML = `
                    <p class="text-center py-3">Error loading recent matches: ${error.message}</p>
                `;
            }
        }
    </script>
    
    <!-- Match Detail Modal -->
    <div class="modal fade" id="matchDetailModal" tabindex="-1" aria-labelledby="matchDetailModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content bg-dark text-white border-gold">
                <div class="modal-header">
                    <h5 class="modal-title" id="matchDetailModalLabel">Match Details</h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="match-detail-content">
                        <!-- Date and location -->
                        <div class="mb-3">
                            <div class="d-flex justify-content-between align-items-center">
                                <div>
                                    <i class="far fa-calendar-alt me-2"></i>
                                    <span id="matchDetailDate"></span>
                                </div>
                                <div id="matchDetailCategory" class="match-category"></div>
                            </div>
                            <div id="matchDetailClub" class="text-muted mt-1"></div>
                        </div>
                        
                        <!-- Teams and scores -->
                        <div class="match-detail-result p-3 mb-3 rounded" style="background-color: rgba(255, 255, 255, 0.1);">
                            <div class="row mb-2">
                                <div class="col-7">
                                    <strong>Players</strong>
                                </div>
                                <div class="col-5 text-end">
                                    <strong>Sets</strong>
                                </div>
                            </div>
                            
                            <!-- Team 1 -->
                            <div class="row mb-2" id="matchDetailTeam1Row">
                                <div class="col-7" id="matchDetailTeam1"></div>
                                <div class="col-5 text-end" id="matchDetailTeam1Score"></div>
                            </div>
                            
                            <!-- Team 2 -->
                            <div class="row" id="matchDetailTeam2Row">
                                <div class="col-7" id="matchDetailTeam2"></div>
                                <div class="col-5 text-end" id="matchDetailTeam2Score"></div>
                            </div>
                        </div>
                        
                        <!-- Set scores details -->
                        <div class="match-set-details mb-3" id="matchDetailSets">
                            <h6>Set Details</h6>
                            <div class="table-responsive">
                                <table class="table table-sm table-dark">
                                    <thead>
                                        <tr>
                                            <th>Set</th>
                                            <th id="matchDetailSetTeam1Header"></th>
                                            <th id="matchDetailSetTeam2Header"></th>
                                        </tr>
                                    </thead>
                                    <tbody id="matchDetailSetScores">
                                        <!-- Set scores will be added here -->
                                    </tbody>
                                </table>
                            </div>
                        </div>
                        
                        <!-- Additional info -->
                        <div class="match-detail-info">
                            <p class="text-muted" id="matchDetailSubmitter"></p>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>
</body>
</html>
